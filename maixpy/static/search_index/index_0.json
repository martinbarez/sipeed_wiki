{"/maixpy/api/index.html":{"title":"MaixPy API -- Maix AI machine vision platform Python API","content":" title: MaixPy API Maix AI machine vision platform Python API **You can read API doc at [MaixPy API on Sipeed Wiki](https://wiki.sipeed.com/maixpy/api/index.html)** If you want to preview API doc offline, build MaixPy, and API doc will be generated in `MaixPy/docs/api/` directory. > For MaixPy developer: This API documentation is generated from the source code, DO NOT edit this file manually! MaixPy API documentation, modules: module brief [maix.err](./maix/err.html) maix.err module [maix.tensor](./maix/tensor.html) maix.tensor module [maix.image](./maix/image.html) maix.image module, image related definition and functions [maix.camera](./maix/camera.html) maix.camera module, access camera device and get image from it [maix.display](./maix/display.html) maix.display module, control display device and show image on it [maix.comm](./maix/comm.html) maix.comm module [maix.thread](./maix/thread.html) maix.thread module [maix.fs](./maix/fs.html) maix.fs module [maix.sys](./maix/sys.html) maix.sys module [maix.time](./maix/time.html) maix.time module [maix.i18n](./maix/i18n.html) maix.i18n module [maix.protocol](./maix/protocol.html) maix.protocol module [maix.example](./maix/example.html) example module, this will be maix.example module in MaixPy, maix::example namespace in MaixCDK [maix.app](./maix/app.html) maix.app module [maix.nn](./maix/nn.html) maix.nn module [maix.peripheral](./maix/peripheral.html) Chip's peripheral driver [maix.touchscreen](./maix/touchscreen.html) maix.touchscreen module "},"/maixpy/api/maix/protocol.html":{"title":"maix.protocol","content":" title: maix.protocol maix.protocol module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.protocol` to access this module. ## Module No module ## Enum ### CMD item doc **brief** protocol cmd, more doc see MaixCDK document's convention doc **note** max app custom CMD value should < CMD_APP_MAX **values** **CMD_APP_MAX**: 200, max app custom CMD value should < CMD_APP_MAX<br>**CMD_SET_UPLOAD**: set auto upload data mode<br>**CMD_APP_LIST**: <br>**CMD_START_APP**: <br>**CMD_EXIT_APP**: <br>**CMD_CUR_APP_INFO**: <br>**CMD_APP_INFO**: <br>**CMD_KEY**: <br>**CMD_TOUCH**: <br> **C++ defination code**: ```cpp enum CMD { CMD_APP_MAX 0xC8, // 200, max app custom CMD value should < CMD_APP_MAX CMD_SET_UPLOAD 0xF8, // set auto upload data mode CMD_APP_LIST 0xF9, CMD_START_APP 0xFA, CMD_EXIT_APP 0xFB, CMD_CUR_APP_INFO 0xFC, CMD_APP_INFO 0xFD, CMD_KEY 0xFE, CMD_TOUCH 0xFF, } ``` ### FLAGS item doc **brief** protocol flags, more doc see MaixCDK document's convention doc **values** **FLAG_REQ**: <br>**FLAG_RESP**: <br>**FLAG_IS_RESP_MASK**: <br>**FLAG_RESP_OK**: <br>**FLAG_RESP_ERR**: <br>**FLAG_RESP_OK_MASK**: <br>**FLAG_REPORT**: <br>**FLAG_REPORT_MASK**: <br>**FLAG_VERSION_MASK**: <br> **C++ defination code**: ```cpp enum FLAGS { FLAG_REQ 0x00, FLAG_RESP 0x80, FLAG_IS_RESP_MASK 0x80, FLAG_RESP_OK 0x40, FLAG_RESP_ERR 0x00, FLAG_RESP_OK_MASK 0x40, FLAG_REPORT 0x20, FLAG_REPORT_MASK 0x20, FLAG_VERSION_MASK 0x03 } ``` ## Variable ### VERSION item doc **brief** protocol version **value** **1** **readonly** True **C++ defination code**: ```cpp const uint8_t VERSION 1 ``` ### HEADER item doc **brief** protocol header **value** **0xBBACCAAA** **readonly** True **C++ defination code**: ```cpp const uint32_t HEADER 0xBBACCAAA ``` ## Function ### crc16\\_IBM item doc **brief** CRC16 IBM **param** **data**: data, bytes type.<br> **return** CRC16 IBM value, uint16_t type. **C++ defination code**: ```cpp uint16_t crc16_IBM(const Bytes *data) ``` ## Class ### MSG item doc **brief** protocol msg **C++ defination code**: ```cpp class MSG ``` #### version item doc **type** var **brief** protocol version **static** False **readonly** False **C++ defination code**: ```cpp uint8_t version ``` #### resp\\_ok item doc **type** var **brief** Is success response or not, (only for response msg) **static** False **readonly** False **C++ defination code**: ```cpp uint8_t resp_ok ``` #### cmd item doc **type** var **brief** CMD value **static** False **readonly** False **C++ defination code**: ```cpp uint8_t cmd ``` #### is\\_resp item doc **type** var **brief** message is response or not, contrast with is_req **static** False **readonly** False **C++ defination code**: ```cpp bool is_resp ``` #### body\\_len item doc **type** var **brief** Message body length, read only, use set_body() to update **attention** DO NOT manually change this value **static** False **readonly** False **C++ defination code**: ```cpp int body_len ``` #### encode\\_resp\\_ok item doc **type** func **brief** Encode response ok(success) message **param** **body**: response body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False **C++ defination code**: ```cpp Bytes *encode_resp_ok(Bytes *body nullptr) ``` #### encode\\_report item doc **type** func **brief** Encode proactively report message **param** **body**: report body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False **C++ defination code**: ```cpp Bytes *encode_report(Bytes *body nullptr) ``` #### encode\\_resp\\_err item doc **type** func **brief** Encode response error message **param** **code**: error code<br>**msg**: error message<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False **C++ defination code**: ```cpp Bytes *encode_resp_err(err::Err code, const std::string &msg) ``` #### set\\_body item doc **type** func **brief** Update message body **param** **body_new**: new body data<br> **static** False **C++ defination code**: ```cpp void set_body(Bytes *body_new) ``` #### get\\_body item doc **type** func **brief** Get message body **return** message body, bytes type **static** False **C++ defination code**: ```cpp Bytes *get_body() ``` ### Protocol item doc **brief** Communicate protocol **C++ defination code**: ```cpp class Protocol ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Construct a new Protocol object **param** **buff_size**: Data queue buffer size<br> **static** False **C++ defination code**: ```cpp Protocol(int buff_size 1024) ``` #### buff\\_size item doc **type** func **brief** Data queue buffer size **static** False **C++ defination code**: ```cpp int buff_size() ``` #### push\\_data item doc **type** func **brief** Add data to data queue **param** **new_data**: new data<br> **return** error code, maybe err.Err.ERR_BUFF_FULL **static** False **C++ defination code**: ```cpp err::Err push_data(const Bytes *new_data) ``` #### decode item doc **type** func **brief** Decode data in data queue and return a message **param** **new_data**: new data add to data queue, if null, only decode.<br> **return** decoded message, if nullptr, means no message decoded. **static** False **C++ defination code**: ```cpp protocol::MSG *decode(const Bytes *new_data nullptr) ``` #### encode\\_resp\\_ok item doc **type** func **brief** Encode response ok(success) message to buffer **param** **cmd**: CMD value<br>**body**: response body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False **C++ defination code**: ```cpp Bytes *encode_resp_ok(uint8_t cmd, Bytes *body nullptr) ``` #### encode\\_report item doc **type** func **brief** Encode proactively report message to buffer **param** **cmd**: CMD value<br>**body**: report body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False **C++ defination code**: ```cpp Bytes *encode_report(uint8_t cmd, Bytes *body nullptr) ``` #### encode\\_resp\\_err item doc **type** func **brief** Encode response error message to buffer **param** **cmd**: CMD value<br>**code**: error code<br>**msg**: error message<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False **C++ defination code**: ```cpp Bytes *encode_resp_err(uint8_t cmd, err::Err code, const std::string &msg) ```"},"/maixpy/api/maix/tensor.html":{"title":"maix.tensor","content":" title: maix.tensor maix.tensor module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.tensor` to access this module. ## Module No module ## Enum ### DType item doc **brief** Tensor data types **values** **UINT8**: <br>**INT8**: <br>**UINT16**: <br>**INT16**: <br>**UINT32**: <br>**INT32**: <br>**FLOAT16**: <br>**FLOAT32**: <br>**FLOAT64**: <br>**BOOL**: <br>**DTYPE_MAX**: <br> **C++ defination code**: ```cpp enum DType { UINT8 0, INT8, UINT16, INT16, UINT32, INT32, FLOAT16, FLOAT32, FLOAT64, BOOL, // STRING, // OBJECT, DTYPE_MAX } ``` ## Variable ### dtype\\_size item doc **brief** Tensor data type size in bytes **attention** It's a copy of this variable in MaixPy,<br>so change it in C++ (e.g. update var in hello function) will not take effect the var inMaixPy.<br>So we add const for this var to avoid this mistake. **value** **{<br> 1, // UINT8<br> 1, // INT8<br> 2, // UINT16<br> 2, // INT16<br> 4, // UINT32<br> 4, // INT32<br> 2, // FLOAT16<br> 4, // FLOAT32<br> 8, // FLOAT64<br> 1, // BOOL<br> // 1, // STRING<br> // 1, // OBJECT<br> 0<br> }** **readonly** True **C++ defination code**: ```cpp const std::vector<int> dtype_size { 1, // UINT8 1, // INT8 2, // UINT16 2, // INT16 4, // UINT32 4, // INT32 2, // FLOAT16 4, // FLOAT32 8, // FLOAT64 1, // BOOL // 1, // STRING // 1, // OBJECT 0 } ``` ### dtype\\_name item doc **brief** Tensor data type name **value** **{<br> \"uint8\",<br> \"int8\",<br> \"uint16\",<br> \"int16\",<br> \"uint32\",<br> \"int32\",<br> \"float16\",<br> \"float32\",<br> \"float64\",<br> \"bool\",<br> // \"string\",<br> // \"object\",<br> \"invalid\"<br> }** **readonly** True **C++ defination code**: ```cpp const std::vector<std::string> dtype_name { \"uint8\", \"int8\", \"uint16\", \"int16\", \"uint32\", \"int32\", \"float16\", \"float32\", \"float64\", \"bool\", // \"string\", // \"object\", \"invalid\" } ``` ## Function ## Class ### Tensor item doc **brief** Tensor class **C++ defination code**: ```cpp class Tensor ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Tensor constructor **param** **shape**: tensor shape, a int list<br>**dtype**: tensor element data type, see DType of this module<br>**data**: pointer to data content, can be nullptr, it will automatically alloc memory<br>and detroy it when this object is destroyed<br> **static** False **C++ defination code**: ```cpp Tensor(std::vector<int> shape, tensor::DType dtype, void *data nullptr) ``` #### to\\_str item doc **type** func **brief** To string **static** False **C++ defination code**: ```cpp std::string to_str() ``` #### \\_\\_str\\_\\_ item doc **type** func **brief** To string **static** False **C++ defination code**: ```cpp std::string __str__() ``` #### shape item doc **type** func **brief** get tensor shape **return** tensor shape, a int list **static** False **C++ defination code**: ```cpp std::vector<int> shape() ``` #### expand\\_dims item doc **type** func **brief** expand tensor shape **param** **axis**: axis to expand<br> **static** False **C++ defination code**: ```cpp void expand_dims(int axis) ``` #### reshape item doc **type** func **brief** reshape tensor shape, if size not match, it will throw an err::Exception **param** **shape**: new shape<br> **static** False **C++ defination code**: ```cpp void reshape(std::vector<int> shape) ``` #### flatten item doc **type** func **brief** Flatten tensor shape to 1D **static** False **C++ defination code**: ```cpp void flatten() ``` #### dtype item doc **type** func **brief** get tensor data type **return** tensor data type, see DType of this module **static** False **C++ defination code**: ```cpp tensor::DType dtype() ``` #### argmax item doc **type** func **brief** argmax of tensor **param** **axis**: By default, the index is into the flattened array, otherwise along the specified axis., wrong axis will throw an err::Exception<br> **return** argmax result, you need to delete it after use in C++. **static** False **C++ defination code**: ```cpp tensor::Tensor *argmax(int axis 0xffff) ``` #### argmax1 item doc **type** func **brief** argmax1, flattened data max index **return** argmax result, int type **static** False **C++ defination code**: ```cpp int argmax1() ``` ### Tensors item doc **brief** Tensors **C++ defination code**: ```cpp class Tensors ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Constructor of Tensors **static** False **C++ defination code**: ```cpp Tensors() ``` #### add\\_tensor item doc **type** func **brief** Add tensor **static** False **C++ defination code**: ```cpp void add_tensor(const std::string &key, tensor::Tensor *tensor, bool copy, bool auto_delete) ``` #### rm\\_tensor item doc **type** func **brief** Remove tensor **static** False **C++ defination code**: ```cpp void rm_tensor(const std::string &key) ``` #### get\\_tensor item doc **type** func **brief** Get tensor by key **static** False **C++ defination code**: ```cpp tensor::Tensor *get_tensor(const std::string &key) ``` #### \\_\\_getitem\\_\\_ item doc **type** func **brief** Operator [] **static** False **C++ defination code**: ```cpp tensor::Tensor *operator[](const std::string &key) ``` #### \\_\\_len\\_\\_ item doc **type** func **brief** Size **static** False **C++ defination code**: ```cpp size_t size() ``` #### get\\_names item doc **type** func **brief** Get names **static** False **C++ defination code**: ```cpp std::vector<std::string> get_names() ``` #### tensors item doc **type** var **brief** Tensors data, dict type **static** False **readonly** False **C++ defination code**: ```cpp std::map<std::string, tensor::Tensor*> tensors ```"},"/maixpy/api/maix/nn/F.html":{"title":"maix.nn.F","content":" title: maix.nn.F maix.nn.F module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.nn.F` to access this module. ## Module No module ## Enum ## Variable ## Function ### softmax item doc **brief** Softmax, only support 1D tensor, multi dimension tensor will be treated as 1D tensor **param** **tensor**: input tensor<br>**replace**: change input tensor data directly, if not, will create a new tensor<br> **throw** If arg error, will raise err.Exception error **return** output tensor, if arg replace is true, return the arg tensor's address.<br>If not replace, return a new object, so In C++, you should delete it manually in this case! **C++ defination code**: ```cpp tensor::Tensor *softmax(tensor::Tensor *tensor, bool replace) ``` ## Class"},"/maixpy/api/maix/peripheral.html":{"title":"maix.peripheral","content":" title: maix.peripheral Chip's peripheral driver > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.peripheral` to access this module. ## Module module brief [timer](./peripheral/timer.html) maix.peripheral.timer module [wdt](./peripheral/wdt.html) maix.peripheral.wdt module [pwm](./peripheral/pwm.html) maix.peripheral.pwm module [gpio](./peripheral/gpio.html) maix.peripheral.gpio module [spi](./peripheral/spi.html) maix.peripheral.spi module [uart](./peripheral/uart.html) maix uart peripheral driver [key](./peripheral/key.html) maix.peripheral.key module [i2c](./peripheral/i2c.html) maix.peripheral.i2c module [adc](./peripheral/adc.html) maix.peripheral.adc module ## Enum ## Variable ## Function ## Class"},"/maixpy/api/maix/app.html":{"title":"maix.app","content":" title: maix.app maix.app module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.app` to access this module. ## Module No module ## Enum ## Variable ## Function ### app\\_id item doc **brief** Get current APP ID. **return** APP ID. **C++ defination code**: ```cpp string app_id() ``` ### set\\_app\\_id item doc **brief** Set current APP ID. **param** **app_id**: APP ID.<br> **C++ defination code**: ```cpp string set_app_id(const string &app_id) ``` ### get\\_apps\\_info\\_path item doc **brief** Get APP info file path. **C++ defination code**: ```cpp string get_apps_info_path() ``` ### get\\_apps\\_info item doc **brief** Get APP info list. **param** **ignore_launcher**: if true, ignore launcher APP. default false.<br>**ignore_app_store**: if true, ignore app store APP. default false.<br> **return** APP info list. APP_Info object list. **C++ defination code**: ```cpp vector<app::APP_Info> &get_apps_info(bool ignore_launcher false, bool ignore_app_store false) ``` ### get\\_app\\_data\\_path item doc **brief** Get APP info, APP can store private data in this directory. **return** APP data path \"./data\", just return the data folder in current path because APP executed in app install path or project path.<br>So, you must execute your program in you project path to use the project/data folder when you debug your APP. **C++ defination code**: ```cpp string get_app_data_path() ``` ### get\\_app\\_path item doc **brief** Get APP path. **param** **app_id**: APP ID, if empty, return current APP path, else return the APP path by app_id.<br> **return** APP path, just return the current path because APP executed in app install path or project path.<br>So, you must execute your program in you project path to use the project/data folder when you debug your APP. **C++ defination code**: ```cpp string get_app_path(const string &app_id \"\") ``` ### get\\_tmp\\_path item doc **brief** Get global temporary data path, APPs can use this path as temporary data directory. **return** temporary data path. **C++ defination code**: ```cpp string get_tmp_path() ``` ### get\\_share\\_path item doc **brief** Get data path of share, shared data like picture and video will put in this directory **return** share data path. **C++ defination code**: ```cpp string get_share_path() ``` ### get\\_picture\\_path item doc **brief** Get picture path of share, shared picture will put in this directory **return** share picture path. **C++ defination code**: ```cpp string get_picture_path() ``` ### get\\_video\\_path item doc **brief** Get video path of share, shared video will put in this directory **return** share video path. **C++ defination code**: ```cpp string get_video_path() ``` ### get\\_font\\_path item doc **brief** Get font path of share, shared font will put in this directory **return** share font path. **C++ defination code**: ```cpp string get_font_path() ``` ### get\\_icon\\_path item doc **brief** Get icon path of share, shared icon will put in this directory **return** share icon path. **C++ defination code**: ```cpp string get_icon_path() ``` ### get\\_sys\\_config\\_kv item doc **brief** Get system config item value. **param** **item**: name of setting item, e.g. wifi, language. more see settings APP.<br>**key**: config key, e.g. for wifi, key can be ssid, for language, key can be locale.<br>**value**: default value, if not found, return this value.<br>**from_cache**: if true, read from cache, if false, read from file.<br> **return** config value, always string type, if not found, return empty string. **C++ defination code**: ```cpp string get_sys_config_kv(const string &item, const string &key, const string &value \"\", bool from_cache true) ``` ### get\\_app\\_config\\_kv item doc **brief** Get APP config item value. **param** **item**: name of setting item, e.g. user_info<br>**key**: config key, e.g. for user_info, key can be name, age etc.<br>**value**: default value, if not found, return this value.<br>**from_cache**: if true, read from cache, if false, read from file.<br> **return** config value, always string type, if not found, return empty string. **C++ defination code**: ```cpp string get_app_config_kv(const string &item, const string &key, const string &value \"\", bool from_cache true) ``` ### set\\_app\\_config\\_kv item doc **brief** Set APP config item value. **param** **item**: name of setting item, e.g. user_info<br>**key**: config key, e.g. for user_info, key can be name, age etc.<br>**value**: config value, always string type.<br>**write_file**: if true, write to file, if false, just write to cache.<br> **return** err::Err **C++ defination code**: ```cpp err::Err set_app_config_kv(const string &item, const string &key, const string &value, bool write_file true) ``` ### get\\_app\\_config\\_path item doc **brief** Get APP config path, ini format, so you can use your own ini parser to parse it like `configparser` in Python.\\nAll APP config info is recommended to store in this file. **return** APP config path(ini format). **C++ defination code**: ```cpp string get_app_config_path() ``` ### set\\_exit\\_msg item doc **brief** Set APP exit code and exit message.\\nIf code ! 0, the launcher will show a dialog to user, and display the msg. **param** **code**: exit code, 0 means success, other means error, if code is 0, do nothing.<br>**msg**: exit message, if code is 0, msg is not used.<br> **return** exit code, the same as arg @code. **C++ defination code**: ```cpp err::Err set_exit_msg(err::Err code, const string &msg) ``` ### get\\_exit\\_msg item doc **brief** Get APP exit code and exit message. **param** **cache**: if true, read from cache, if false, read from file. default false.<br> **return** exit return app_id, exit code and exit message. **C++ defination code**: ```cpp tuple<string, err::Err, string> get_exit_msg(bool cache false) ``` ### have\\_exit\\_msg item doc **brief** Check if have exit msg **param** **cache**: if true, just check from cache, if false, check from file. default false.<br> **return** true if have exit msg, false if not. **C++ defination code**: ```cpp bool have_exit_msg(bool cache false) ``` ### switch\\_app item doc **brief** Exit this APP and start another APP(by launcher).\\nCall this API will call set_exit_flag(true), you should check app::need_exit() in your code.\\nAnd exit this APP if app::need_exit() return true. **param** **app_id**: APP ID which will be started. app_id and idx must have one is valid.<br>**idx**: APP index. app_id and idx must have one is valid.<br> **C++ defination code**: ```cpp void switch_app(const string &app_id, int idx 1) ``` ### need\\_exit item doc **brief** Shoule this APP exit? **return** true if this APP should exit, false if not. **attention** This API is a function, not a variable. **C++ defination code**: ```cpp bool need_exit() ``` ### running item doc **brief** App should running? The same as !app::need_exit() (not app::need_exit() in MaixPy). **return** true if this APP should running, false if not. **attention** This API is a function, not a variable. **C++ defination code**: ```cpp bool running() ``` ### set\\_exit\\_flag item doc **brief** Set exit flag. You can get exit flag by app.need_exit(). **param** **exit**: true if this APP should exit, false if not.<br> **C++ defination code**: ```cpp void set_exit_flag(bool exit) ``` ## Class ### Version item doc **brief** APP version **C++ defination code**: ```cpp class Version ``` #### \\_\\_str\\_\\_ item doc **type** func **brief** Convert to string, e.g. 1.0.0 **static** False **C++ defination code**: ```cpp std::string __str__() ``` #### from\\_str item doc **type** func **brief** Convert from string, e.g. \\\"1.0.0\\\" **static** True **C++ defination code**: ```cpp static app::Version from_str(const string &version_str) ``` ### APP\\_Info item doc **brief** APP info **C++ defination code**: ```cpp class APP_Info ``` #### id item doc **type** var **brief** APP id **static** False **readonly** False **C++ defination code**: ```cpp string id ``` #### name item doc **type** var **brief** APP name **static** False **readonly** False **C++ defination code**: ```cpp string name ``` #### icon item doc **type** var **brief** APP icon **static** False **readonly** False **C++ defination code**: ```cpp string icon ``` #### version item doc **type** var **brief** APP version **static** False **readonly** False **C++ defination code**: ```cpp Version version ``` #### exec item doc **type** var **brief** APP exec **static** False **readonly** False **C++ defination code**: ```cpp string exec ``` #### author item doc **type** var **brief** APP author **static** False **readonly** False **C++ defination code**: ```cpp string author ``` #### desc item doc **type** var **brief** APP desc **static** False **readonly** False **C++ defination code**: ```cpp string desc ``` #### names item doc **type** var **brief** APP names **static** False **readonly** False **C++ defination code**: ```cpp map<string, string> names ``` #### descs item doc **type** var **brief** APP descs **static** False **readonly** False **C++ defination code**: ```cpp map<string, string> descs ```"},"/maixpy/api/maix/i18n.html":{"title":"maix.i18n","content":" title: maix.i18n maix.i18n module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.i18n` to access this module. ## Module No module ## Enum ## Variable ### locales item doc **brief** i18n locales list **value** **{<br> \"en\",<br> \"zh\",<br> \"zh tw\",<br> \"ja\"<br> }** **readonly** False **C++ defination code**: ```cpp static std::vector<std::string> locales { \"en\", \"zh\", \"zh tw\", \"ja\" } ``` ### names item doc **brief** i18n language names list **value** **{<br> \"English\",<br> \"简体中文\",<br> \"繁體中文\",<br> \"日本語\"<br> }** **readonly** True **C++ defination code**: ```cpp const static std::vector<std::string> names { \"English\", \"简体中文\", \"繁體中文\", \"日本語\" } ``` ## Function ### get\\_locale item doc **brief** Get system config of locale. **return** language locale, e.g. en, zh, zh_CN, zh_TW, etc. **C++ defination code**: ```cpp string get_locale() ``` ### get\\_language\\_name item doc **brief** Get system config of language name. **return** language name, e.g. English, 简体中文, 繁體中文, etc. **C++ defination code**: ```cpp string get_language_name() ``` ## Class ### Trans item doc **brief** Translate helper class. **C++ defination code**: ```cpp class Trans ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Translate helper class constructor.\\nBy default locale is get by `i18n.get_locale()` function which set by system settings.\\nBut you can also manually set by `set_locale` function temporarily. **param** **locales_dict**: locales dict, e.g. {\"zh\": {\"Confirm\": \"确认\", \"OK\": \"好的\"}, \"en\": {\"Confirm\": \"Confirm\", \"OK\": \"OK\"}}<br> **static** False **C++ defination code**: ```cpp Trans(const std::map<string, const std::map<string, string>> &locales_dict) ``` #### tr item doc **type** func **brief** Translate string by key. **param** **key**: string key, e.g. \"Confirm\"<br>**locale**: locale name, if not assign, use default locale set by system settings or set_locale function.<br> **return** translated string, if find translation, return it, or return key, e.g. \"确认\", \"Confirm\", etc. **static** False **C++ defination code**: ```cpp string tr(const string &key, const string locale \"\") ``` #### set\\_locale item doc **type** func **brief** Set locale temporarily, will not affect system settings. **param** **locale**: locale name, e.g. \"zh\", \"en\", etc. @see maix.i18n.locales<br> **static** False **C++ defination code**: ```cpp void set_locale(const string &locale) ``` #### get\\_locale item doc **type** func **brief** Get current locale. **return** locale name, e.g. \"zh\", \"en\", etc. @see maix.i18n.locales **static** False **C++ defination code**: ```cpp string get_locale() ```"},"/maixpy/api/maix/example.html":{"title":"maix.example","content":" title: maix.example example module, this will be maix.example module in MaixPy, maix::example namespace in MaixCDK > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.example` to access this module. ## Module No module ## Enum ### Kind item doc **brief** Example enum **values** **KIND_NONE**: Kind none, value always 0, other enum value will auto increase<br>**KIND_DOG**: Kind dog<br>**KIND_CAT**: Kind cat, value is auto generated according to KING_DOG<br>**KIND_BIRD**: <br>**KIND_MAX**: Max Kind quantity<br>You can get max Kind value by KIND_MAX 1<br> **C++ defination code**: ```cpp enum Kind { KIND_NONE 0, /** Kind none, value always 0, other enum value will auto increase */ KIND_DOG, /** Kind dog*/ KIND_CAT, // Kind cat, value is auto generated according to KING_DOG KIND_BIRD, KIND_MAX /* Max Kind quantity, You can get max Kind value by KIND_MAX 1 */ } ``` ## Variable ### var1 item doc **brief** Example module variable **attention** It's a copy of this variable in MaixPy,<br>so change it in C++ (e.g. update var in hello function) will not take effect the var inMaixPy.<br>So we add const for this var to avoid this mistake. **value** **\"Sipeed\"** **readonly** True **C++ defination code**: ```cpp const std::string var1 \"Sipeed\" ``` ### list\\_var item doc **brief** Tensor data type size in bytes **attention** **1**. DO NOT use C/C++ array directly for python API, the python wrapper not support it.<br>Use std::vector instead.<br>**2**. It's a copy of this variable in MaixPy,<br>so change it in C++ (e.g. update var in hello function) will not take effect the var inMaixPy.<br>So we add const for this var to avoid this mistake.<br> **value** **{<br> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9}** **readonly** True **C++ defination code**: ```cpp const std::vector<int> list_var { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9} ``` ### test\\_var item doc **brief** Example module variable test_var **attention** It's a copy of this variable in MaixPy, so if you change it in C++, it will not take effect in MaixPy.<br>And change it in MaixPy will not take effect in C++ as well !!!<br>If you want to use vars shared between C++ and MaixPy, you can create a class and use its member. **value** **100** **readonly** False **C++ defination code**: ```cpp int test_var 100 ``` ## Function ### hello item doc **brief** say hello to someone **param** **name**: direction [in], name of someone, string type<br> **return** string type, content is hello + name **C++ defination code**: ```cpp std::string hello(std::string name) ``` ### change\\_arg\\_name item doc **brief** Change arg name example **param** **e**: Example object<br> **return** same as arg **C++ defination code**: ```cpp example::Example *change_arg_name(example::Example *e) ``` ### change\\_arg\\_name2 item doc **brief** Change arg name example **param** **e**: Example object<br> **C++ defination code**: ```cpp void change_arg_name2(example::Example &e) ``` ## Class ### Test item doc **brief** Test class **C++ defination code**: ```cpp class Test ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Test constructor **static** False **C++ defination code**: ```cpp Test() ``` ### Example item doc **brief** Example class\\nthis class will be export to MaixPy as maix.example.Example **C++ defination code**: ```cpp class Example ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Example constructor\\nthis constructor will be export to MaixPy as maix.example.Example.__init__ **param** **name**: direction [in], name of Example, string type<br>**age**: direction [in], age of Example, int type, default is 18, value range is [0, 100]<br> **attention** to make auto generate code work, param Kind should with full namespace name `example::Kind` instead of `Kind`,<br>namespace `maix` can be ignored. **static** False **C++ defination code**: ```cpp Example(std::string &name, int age 18, example::Kind pet example::KIND_NONE) ``` #### get\\_name item doc **type** func **brief** get name of Example\\nyou can also get name by property `name`. **return** name of Example, string type **static** False **C++ defination code**: ```cpp std::string get_name() ``` #### get\\_age item doc **type** func **brief** get age of Example **return** age of Example, int type, value range is [0, 100] **static** False **C++ defination code**: ```cpp int get_age() ``` #### set\\_name item doc **type** func **brief** set name of Example **param** **name**: name of Example, string type<br> **static** False **C++ defination code**: ```cpp void set_name(std::string name) ``` #### set\\_age item doc **type** func **brief** set age of Example **param** **age**: age of Example, int type, value range is [0, 100]<br> **static** False **C++ defination code**: ```cpp void set_age(int age) ``` #### set\\_pet item doc **type** func **brief** Example enum member **attention** **static** False **C++ defination code**: ```cpp void set_pet(example::Kind pet) ``` #### get\\_pet item doc **type** func **brief** Example enum member **static** False **C++ defination code**: ```cpp example::Kind get_pet() ``` #### get\\_list item doc **type** func **brief** get list example **param** **in**: direction [in], input list, items are int type.<br>In MaixPy, you can pass list or tuple to this API<br> **return** list, items are int type, content is [1, 2, 3] + in. Alloc item, del in MaixPy will auto free memory. **static** False **C++ defination code**: ```cpp std::vector<int> *get_list(std::vector<int> in) ``` #### get\\_dict item doc **type** func **brief** Example dict API **param** **in**: direction [in], input dict, key is string type, value is int type.<br>In MaixPy, you can pass `dict` to this API<br> **return** dict, key is string type, value is int type, content is {\"a\": 1} + in<br>In MaixPy, return type is `dict` object **static** False **C++ defination code**: ```cpp std::map<std::string, int> get_dict(std::map<std::string, int> &in) ``` #### hello item doc **type** func **brief** say hello to someone **param** **name**: name of someone, string type<br> **return** string type, content is Example::hello_str + name **static** True **C++ defination code**: ```cpp static std::string hello(std::string name) ``` #### hello\\_bytes item doc **type** func **brief** param is bytes example **param** **bytes**: bytes type param<br> **return** bytes type, return value is bytes changed value **static** True **C++ defination code**: ```cpp static Bytes *hello_bytes(Bytes &bytes) ``` #### callback item doc **type** func **brief** Callback example **param** **cb**: callback function, param is two int type, return is int type<br> **return** int type, return value is cb(1, 2) **static** True **C++ defination code**: ```cpp static int callback(std::function<int(int, int)> cb) ``` #### hello\\_dict item doc **type** func **brief** Dict param example **param** **dict**: dict type param, key is string type, value is int type<br> **static** True **C++ defination code**: ```cpp static std::map<std::string, int> *hello_dict(std::map<std::string, int> *dict) ``` #### name item doc **type** var **brief** name member of Example **static** False **readonly** False **C++ defination code**: ```cpp std::string name ``` #### age item doc **type** var **brief** age member of Example, value range should be [0, 100] **static** False **readonly** False **C++ defination code**: ```cpp int age ``` #### hello\\_str item doc **type** var **brief** hello_str member of Example, default value is \\\"hello \\\" **static** True **readonly** False **C++ defination code**: ```cpp static std::string hello_str ``` #### var1 item doc **type** var **brief** Example module readonly variable **static** False **readonly** True **C++ defination code**: ```cpp const std::string var1 \"Example.var1\" ``` #### var2 item doc **type** var **brief** Example module readonly variable **static** False **readonly** True **C++ defination code**: ```cpp std::string var2 \"Example.var2\" ``` #### dict\\_test item doc **type** func **brief** dict_test, return dict type, and element is pointer type(alloc in C++).\\nHere when the returned Tensor object will auto delete by Python GC. **static** True **C++ defination code**: ```cpp static std::map<std::string, example::Test *> *dict_test() ```"},"/maixpy/api/maix/thread.html":{"title":"maix.thread","content":" title: maix.thread maix.thread module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.thread` to access this module. ## Module No module ## Enum ## Variable ## Function ## Class ### Thread item doc **brief** thread class **C++ defination code**: ```cpp class Thread ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** create thread **param** **func**: direction [in], thread function, one `args` parameter, void* type, no return value<br>**args**: direction [in], thread function parameter<br> **static** False **C++ defination code**: ```cpp Thread(std::function<void(void *)> func, void *args nullptr) ``` #### join item doc **type** func **brief** wait thread exit **static** False **C++ defination code**: ```cpp void join() ``` #### detach item doc **type** func **brief** detach thread **static** False **C++ defination code**: ```cpp void detach() ``` #### joinable item doc **type** func **brief** Check if thread is joinable **return** true if thread is joinable **static** False **C++ defination code**: ```cpp bool joinable() ```"},"/maixpy/api/maix/err.html":{"title":"maix.err","content":" title: maix.err maix.err module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.err` to access this module. ## Module No module ## Enum ### Err item doc **brief** Maix Error code **values** **ERR_NONE**: No error<br>**ERR_ARGS**: Invalid arguments<br>**ERR_NO_MEM**: No memory<br>**ERR_NOT_IMPL**: Not implemented<br>**ERR_NOT_READY**: Not ready<br>**ERR_NOT_INIT**: Not initialized<br>**ERR_NOT_OPEN**: Not opened<br>**ERR_NOT_PERMIT**: Not permitted<br>**ERR_REOPEN**: Re open<br>**ERR_BUSY**: Busy<br>**ERR_READ**: Read error<br>**ERR_WRITE**: Write error<br>**ERR_TIMEOUT**: Timeout<br>**ERR_RUNTIME**: Runtime error<br>**ERR_IO**: IO error<br>**ERR_NOT_FOUND**: Not found<br>**ERR_ALREAY_EXIST**: Already exist<br>**ERR_BUFF_FULL**: Buffer full<br>**ERR_BUFF_EMPTY**: Buffer empty<br>**ERR_CANCEL**: Cancel<br>**ERR_OVERFLOW**: Overflow<br>**ERR_MAX**: <br> **C++ defination code**: ```cpp enum Err { // !!! fixed error code, DO NOT change number already defined, only append new error code ERR_NONE 0, // No error ERR_ARGS , // Invalid arguments ERR_NO_MEM , // No memory ERR_NOT_IMPL , // Not implemented ERR_NOT_READY , // Not ready ERR_NOT_INIT , // Not initialized ERR_NOT_OPEN , // Not opened ERR_NOT_PERMIT , // Not permitted ERR_REOPEN , // Re open ERR_BUSY , // Busy ERR_READ , // Read error ERR_WRITE , // Write error ERR_TIMEOUT , // Timeout ERR_RUNTIME , // Runtime error ERR_IO , // IO error ERR_NOT_FOUND , // Not found ERR_ALREAY_EXIST , // Already exist ERR_BUFF_FULL , // Buffer full ERR_BUFF_EMPTY , // Buffer empty ERR_CANCEL , // Cancel ERR_OVERFLOW , // Overflow ERR_MAX, } ``` ## Variable ## Function ### to\\_str item doc **brief** Error code to string **param** **e**: direction [in], error code, err::Err type<br> **return** error string **C++ defination code**: ```cpp std::string to_str(err::Err e) ``` ### get\\_error item doc **brief** get last error string **return** error string **C++ defination code**: ```cpp std::string& get_error() ``` ### set\\_error item doc **brief** set last error string **param** **str**: direction [in], error string<br> **C++ defination code**: ```cpp void set_error(const std::string &str) ``` ### check\\_raise item doc **brief** Check error code, if not ERR_NONE, raise err.Exception **param** **e**: direction [in], error code, err::Err type<br>**msg**: direction [in], error message<br> **C++ defination code**: ```cpp void check_raise(err::Err e, const std::string &msg \"\") ``` ### check\\_bool\\_raise item doc **brief** Check condition, if false, raise err.Exception **param** **ok**: direction [in], condition, if true, do nothing, if false, raise err.Exception<br>**msg**: direction [in], error message<br> **C++ defination code**: ```cpp void check_bool_raise(bool ok, const std::string &msg \"\") ``` ### check\\_null\\_raise item doc **brief** Check NULL pointer, if NULL, raise exception **param** **ptr**: direction [in], pointer<br>**msg**: direction [in], error message<br> **C++ defination code**: ```cpp void check_null_raise(void *ptr, const std::string &msg \"\") ``` ## Class ### Exception item doc **brief** Maix Exception **C++ defination code**: ```cpp class Exception : public std::exception ```"},"/maixpy/api/maix/touchscreen.html":{"title":"maix.touchscreen","content":" title: maix.touchscreen maix.touchscreen module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.touchscreen` to access this module. ## Module No module ## Enum ## Variable ## Function ## Class ### TouchScreen item doc **brief** TouchScreen class **C++ defination code**: ```cpp class TouchScreen ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Construct a new TouchScreen object **param** **device**: touchscreen device path, you can get devices by list_devices method, by default(value is NULL(None in MaixPy)) means the first device<br>**open**: If true, touchscreen will automatically call open() after creation. default is true.<br> **static** False **C++ defination code**: ```cpp TouchScreen(const std::string &device \"\", bool open true) ``` #### open item doc **type** func **brief** open touchscreen device **return** error code, err::ERR_NONE means success, others means failed **static** False **C++ defination code**: ```cpp err::Err open() ``` #### close item doc **type** func **brief** close touchscreen device **return** error code, err::ERR_NONE means success, others means failed **static** False **C++ defination code**: ```cpp err::Err close() ``` #### read item doc **type** func **brief** read touchscreen device **attention** This method will discard same event in buffer, that is:<br>if too many move event in buffer when call this method, it will only return the last one,<br>and if read pressed or released event, it will return immediately. **return** Returns a list include x, y, pressed state **static** False **C++ defination code**: ```cpp std::vector<int> read() ``` #### read (overload 1) item doc **type** func **brief** read touchscreen device **attention** This method will return immediately if have event, so it's better to use available() to check if have more event in buffer,<br>or too much event in buffer when your program call this read() interval is too long will make your program slow. **return** Returns a list include x, y, pressed state **static** False **C++ defination code**: ```cpp std::vector<int> read0() ``` #### available item doc **type** func **brief** If we need to read from touchscreen, for event driven touchscreen means have event or not **param** **timeout**: 1 means block, 0 means no block, >0 means timeout, default is 0, unit is ms.<br> **return** true if need to read(have event), false if not **static** False **C++ defination code**: ```cpp bool available(int timeout 0) ``` #### is\\_opened item doc **type** func **brief** Check if touchscreen is opened **return** true if touchscreen is opened, false if not **static** False **C++ defination code**: ```cpp bool is_opened() ```"},"/maixpy/api/maix/peripheral/wdt.html":{"title":"maix.peripheral.wdt","content":" title: maix.peripheral.wdt maix.peripheral.wdt module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.peripheral.wdt` to access this module. ## Module No module ## Enum ## Variable ## Function ## Class ### WDT item doc **brief** Peripheral wdt class **C++ defination code**: ```cpp class WDT ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** WDT constructor **param** **id**: direction [in], id of wdt, int type<br>**feed_ms**: direction [in], feed ms of wdt, int type<br> **static** False **C++ defination code**: ```cpp WDT(int id, int feed_ms) ``` #### feed item doc **type** func **brief** feed wdt **return** error code, if feed success, return err::ERR_NONE **static** False **C++ defination code**: ```cpp int feed() ``` #### stop item doc **type** func **brief** stop wdt **static** False **C++ defination code**: ```cpp int stop() ``` #### restart item doc **type** func **brief** restart wdt **attention** restart WDT after stop it **static** False **C++ defination code**: ```cpp int restart() ```"},"/maixpy/api/maix/peripheral/spi.html":{"title":"maix.peripheral.spi","content":" title: maix.peripheral.spi maix.peripheral.spi module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.peripheral.spi` to access this module. ## Module No module ## Enum ## Variable ### MASTER\\_MODE item doc **brief** spi master mode **value** **0x1** **readonly** True **C++ defination code**: ```cpp const int MASTER_MODE 0x1 ``` ### SLAVE\\_MODE item doc **brief** spi slave mode **value** **0x2** **readonly** True **C++ defination code**: ```cpp const int SLAVE_MODE 0x2 ``` ### CLOCK\\_MODE\\_0 item doc **brief** clock mode 0 **attention** CPOL 0, CPHA 0<br>means the idle level of the clock is low, data is captured on the first edge of the SPI clock cycle **value** **0x0** **readonly** True **C++ defination code**: ```cpp const int CLOCK_MODE_0 0x0 ``` ### CLOCK\\_MODE\\_1 item doc **brief** clock mode 1 **attention** CPOL 0, CPHA 1<br>means the idle level of the clock is low, data is captured on the second edge of the SPI clock cycle **value** **0x1** **readonly** True **C++ defination code**: ```cpp const int CLOCK_MODE_1 0x1 ``` ### CLOCK\\_MODE\\_2 item doc **brief** clock mode 2 **attention** CPOL 1, CPHA 0<br>means the idle level of the clock is high, data is captured on the first edge of the SPI clock cycle **value** **0x2** **readonly** True **C++ defination code**: ```cpp const int CLOCK_MODE_2 0x2 ``` ### CLOCK\\_MODE\\_3 item doc **brief** clock mode 3 **attention** CPOL 1, CPHA 1<br>means the idle level of the clock is high, data is captured on the second edge of the SPI clock cycle **value** **0x3** **readonly** True **C++ defination code**: ```cpp const int CLOCK_MODE_3 0x3 ``` ## Function ## Class ### SPI item doc **brief** Peripheral spi class **C++ defination code**: ```cpp class SPI ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** SPI constructor **param** **id**: direction [in], id of spi, int type<br>**sclk**: direction [in], sclk pin of spi, int type<br>**mosi**: direction [in], mosi pin of spi, int type<br>**miso**: direction [in], miso pin of spi, int type<br>**cs**: direction [in], cs pin of spi, int type<br>**freq**: direction [in], freq of spi, int type<br>**use_soft_cs**: direction [in], use_soft_cs of spi, int type<br>this param is valid in master mode, when use_soft_cs 1, the<br>cs pin must be operated manually when sending data. default is 1, means use hardware cs<br>**mode**: direction [in], mode of spi, int type<br>option:<br>mode spi.MASTER, means use master mode<br>mode spi.SLAVE, means use slave mode<br>defualt is 1, means use spi.MASTER mode<br>**clock_mode**: direction [in], clock_mode of spi, int type,default is 1<br>option:<br>clock_mode spi.CLOCK_MODE_0, @see CLOCK_MODE_0<br>clock_mode spi.CLOCK_MODE_1, @see CLOCK_MODE_1<br>clock_mode spi.CLOCK_MODE_2, @see CLOCK_MODE_2<br>clock_mode spi.CLOCK_MODE_3, @see CLOCK_MODE_3<br>default is 1, means use CLOCK_MODE_0<br> **static** False **C++ defination code**: ```cpp SPI(int id, int sclk, int mosi, int miso, int cs, int freq, int use_soft_cs 1, int mode 1, int clock_mode 1) ``` #### cs\\_high item doc **type** func **brief** set cs pin to high level **static** False **C++ defination code**: ```cpp int cs_high() ``` #### cs\\_low item doc **type** func **brief** set cs pin to low level **static** False **C++ defination code**: ```cpp int cs_low() ``` #### read item doc **type** func **brief** read data from spi **param** **read_len**: direction [in], read length, int type<br> **return** read data, vector<unsigned char> type **static** False **C++ defination code**: ```cpp std::vector<unsigned char> read(int read_len) ``` #### write item doc **type** func **brief** write data to spi **param** **write_data**: direction [in], write data, vector<unsigned char> type<br>the member range of the list is [0,255]<br> **return** error code, if write success, return err::ERR_NONE **static** False **C++ defination code**: ```cpp int write(std::vector<unsigned char> write_data std::vector<unsigned char>{}) ``` #### read\\_write item doc **type** func **brief** set spi status to high level or low level **param** **write_data**: direction [in], write data, vector<unsigned char> type<br>the member range of the list is [0,255]<br>**read_len**: direction [in], read length, int type<br>default is 1, means read_len write_data.size()<br> **return** read data, vector<unsigned char> type **static** False **C++ defination code**: ```cpp std::vector<unsigned char> read_write( std::vector<unsigned char> write_data std::vector<unsigned char>{}, int read_len 1) ``` #### is\\_busy item doc **type** func **brief** get busy status of spi **return** busy status, bool type **static** False **C++ defination code**: ```cpp bool is_busy() ```"},"/maixpy/api/maix/comm.html":{"title":"maix.comm","content":" title: maix.comm maix.comm module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.comm` to access this module. ## Module No module ## Enum ## Variable ## Function ## Class ### CommProtocol item doc **brief** Class for communication protocol **C++ defination code**: ```cpp class CommProtocol ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Construct a new CommProtocol object **param** **buff_size**: buffer size, default to 1024 bytes<br> **static** False **C++ defination code**: ```cpp CommProtocol(int buff_size 1024) ``` #### get\\_msg item doc **type** func **brief** Read data to buffer, and try to decode it as maix.protocol.MSG object **return** decoded data, if nullptr, means no valid frame found.<br>Attentioin, delete it after use in C++. **static** False **C++ defination code**: ```cpp protocol::MSG *get_msg() ``` #### resp\\_ok item doc **type** func **brief** Send response ok(success) message **param** **cmd**: CMD value<br>**body**: response body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err.<br>Attentioin, delete it after use in C++. **static** False **C++ defination code**: ```cpp err::Err resp_ok(uint8_t cmd, Bytes *body nullptr) ``` #### report item doc **type** func **brief** Send report message **param** **cmd**: CMD value<br>**body**: report body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err.<br>Attentioin, delete it after use in C++. **static** False **C++ defination code**: ```cpp err::Err report(uint8_t cmd, Bytes *body nullptr) ``` #### resp\\_err item doc **type** func **brief** Encode response error message to buffer **param** **cmd**: CMD value<br>**code**: error code<br>**msg**: error message<br> **return** encoded data, if nullptr, means error, and the error code is err.Err.<br>Attentioin, delete it after use in C++. **static** False **C++ defination code**: ```cpp err::Err resp_err(uint8_t cmd, err::Err code, const std::string &msg) ```"},"/maixpy/api/maix/sys.html":{"title":"maix.sys","content":" title: maix.sys maix.sys module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.sys` to access this module. ## Module No module ## Enum ## Variable ## Function ### os\\_version() item doc **brief** Get system version **return** version string, e.g. \"2024.4.1 13af4b\" **C++ defination code**: ```cpp std::string os_version() ``` ### device\\_name() item doc **brief** Get device name **return** device name, e.g. \"MaixCAM\" **C++ defination code**: ```cpp std::string device_name() ``` ### host\\_name() item doc **brief** Get host name **return** host name, e.g. \"maixcam 2f9f\" **C++ defination code**: ```cpp std::string host_name() ``` ### host\\_domain() item doc **brief** Get host domain **return** host domain, e.g. \"maixcam 2f9f.local\" **C++ defination code**: ```cpp std::string host_domain() ``` ### ip\\_address() item doc **brief** Get ip address **return** ip address, dict type, e.g. {\"eth0\": \"192.168.0.195\", \"wlan0\": \"192.168.0.123\", \"usb0\": \"10.47.159.1\"} **C++ defination code**: ```cpp std::map<std::string, std::string> ip_address() ``` ### mac\\_address() item doc **brief** Get mac address **return** mac address, dict type, e.g. {\"eth0\": \"00:0c:29:2f:9f:00\", \"wlan0\": \"00:0c:29:2f:9f:01\", \"usb0\": \"00:0c:29:2f:9f:02\"} **C++ defination code**: ```cpp std::map<std::string, std::string> mac_address() ``` ### device\\_key() item doc **brief** Get device key, can be unique id of device **return** device key, 32 bytes hex string, e.g. \"1234567890abcdef1234567890abcdef\" **C++ defination code**: ```cpp std::string device_key() ``` ### memory\\_info() item doc **brief** Get memory info **return** memory info, dict type, e.g. {\"total\": 1024, \"used\": 512, \"hw_total\": 256*1024*1024}<br>total: total memory size in Byte.<br>used: used memory size in Byte.<br>hw_total: total memory size in Byte of hardware, the total < hw_total，<br>OS kernel may reserve some memory for some hardware like camera, npu, display etc. **C++ defination code**: ```cpp std::map<std::string, int> memory_info() ``` ### bytes\\_to\\_human(1234) item doc **brief** Bytes to human readable string **param** **bytes:**: bytes size，e.g. 1234B 1234/1024 1.205 KB<br>**precision:**: decimal precision, default 2<br>**base:**: base number, default 1024<br>**unit:**: unit string, e.g. \"B\"<br>**sep:**: separator string, e.g. \" \"<br> **return** human readable string, e.g. \"1.21 KB\" **C++ defination code**: ```cpp std::string bytes_to_human(unsigned long long bytes, int precision 2, int base 1024, const std::string &unit \"B\", const std::string &sep \" \") ``` ### cpu\\_freq() item doc **brief** Get CPU frequency **return** CPU frequency, dict type, e.g. {\"cpu0\": 1000000000, \"cpu1\": 1000000000} **C++ defination code**: ```cpp std::map<std::string, unsigned long> cpu_freq() ``` ### cpu\\_temp() item doc **brief** Get CPU temperature **return** CPU temperature, unit dgree, dict type, e.g. {\"cpu\": 50.0, \"cpu0\": 50, \"cpu1\": 50} **C++ defination code**: ```cpp std::map<std::string, float> cpu_temp() ``` ### cpu\\_usage() item doc **brief** Get CPU usage **return** CPU usage, dict type, e.g. {\"cpu\": 50.0, \"cpu0\": 50, \"cpu1\": 50} **C++ defination code**: ```cpp std::map<std::string, float> cpu_usage() ``` ### npu\\_freq() item doc **brief** Get NPU frequency **return** NPU frequency, dict type, e.g. {\"npu0\": 500000000} **C++ defination code**: ```cpp std::map<std::string, unsigned long> npu_freq() ``` ### disk\\_usage() item doc **brief** Get disk usage **param** **path:**: disk path, default \"/\"<br> **return** disk usage, dict type, e.g. {\"total\": 1024, \"used\": 512} **C++ defination code**: ```cpp std::map<std::string, unsigned long long> disk_usage(const std::string &path \"/\") ``` ### disk\\_partitions() item doc **brief** Get disk partition and mount point info **param** **only_disk**: only return real disk, tempfs sysfs etc. not return, default true.<br> **return** disk partition and mount point info, list type, e.g. [{\"device\": \"/dev/mmcblk0p1\", \"mountpoint\": \"/mnt/sdcard\", \"fstype\": \"vfat\"}] **C++ defination code**: ```cpp std::vector<std::map<std::string, std::string>> disk_partitions(bool only_disk true) ``` ## Class"},"/maixpy/api/maix/display.html":{"title":"maix.display","content":" title: maix.display maix.display module, control display device and show image on it > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.display` to access this module. ## Module No module ## Enum ## Variable ## Function ### send\\_to\\_maixvision item doc **brief** Send image to MaixVision work station if connected.\\nIf you want to debug your program an don't want to initialize display, use this method. **param** **img**: image to send, image.Image object<br> **C++ defination code**: ```cpp void send_to_maixvision(image::Image &img) ``` ## Class ### Display item doc **brief** Display class **C++ defination code**: ```cpp class Display ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Construct a new Display object **param** **width**: display width, by default(value is 1) means auto detect,<br>if width > max device supported width, will auto set to max device supported width<br>**height**: display height, by default(value is 1) means auto detect,<br>if height > max device supported height, will auto set to max device supported height<br>**device**: display device name, you can get devices by list_devices method, by default(value is NULL(None in MaixPy)) means the first device<br>**open**: If true, display will automatically call open() after creation. default is true.<br> **static** False **C++ defination code**: ```cpp Display(int width 1, int height 1, image::Format format image::FMT_RGB888, const char *device nullptr, bool open true) ``` #### width item doc **type** func **brief** Get display width **return** width **static** False **C++ defination code**: ```cpp int width() ``` #### height item doc **type** func **brief** Get display height **param** **ch**: channel to get, by default(value is 0) means the first channel<br> **return** height **static** False **C++ defination code**: ```cpp int height() ``` #### size item doc **type** func **brief** Get display size **param** **ch**: channel to get, by default(value is 0) means the first channel<br> **return** size A list type in MaixPy, [width, height] **static** False **C++ defination code**: ```cpp std::vector<int> size() ``` #### format item doc **type** func **brief** Get display format **return** format **static** False **C++ defination code**: ```cpp image::Format format() ``` #### open item doc **type** func **brief** open display device, if already opened, will return err.ERR_NONE. **param** **width**: display width, default is 1, means auto, mostly means max width of display support<br>**height**: display height, default is 1, means auto, mostly means max height of display support<br>**format**: display output format, default is RGB888<br> **return** error code **static** False **C++ defination code**: ```cpp err::Err open(int width 1, int height 1, image::Format format image::FMT_INVALID) ``` #### close item doc **type** func **brief** close display device **return** error code **static** False **C++ defination code**: ```cpp err::Err close() ``` #### add\\_channel item doc **type** func **brief** Add a new channel and return a new Display object, you can use close() to close this channel. **param** **width**: display width, default is 1, means auto, mostly means max width of display support<br>**height**: display height, default is 1, means auto, mostly means max height of display support<br>**format**: display output format, default is RGB888<br>**open**: If true, display will automatically call open() after creation. default is true.<br> **return** new Display object **static** False **C++ defination code**: ```cpp display::Display *add_channel(int width 1, int height 1, image::Format format image::FMT_RGB888, bool open true) ``` #### is\\_opened item doc **type** func **brief** check display device is opened or not **return** opened or not, bool type **static** False **C++ defination code**: ```cpp bool is_opened() ``` #### is\\_closed item doc **type** func **brief** check display device is closed or not **return** closed or not, bool type **static** False **C++ defination code**: ```cpp bool is_closed() ``` #### show item doc **type** func **brief** show image on display device, and will also send to MaixVision work station if connected. **param** **img**: image to show, image.Image object,<br>if the size of image smaller than display size, will show in the center of display;<br>if the size of image bigger than display size, will auto resize to display size and keep ratio, fill blank with black color.<br>**fit**: image in screen fit mode, by default(value is image.FIT_CONTAIN), @see image.Fit for more details<br>e.g. image.FIT_CONTAIN means resize image to fit display size and keep ratio, fill blank with black color.<br> **return** error code **static** False **C++ defination code**: ```cpp err::Err show(image::Image &img, image::Fit fit image::FIT_CONTAIN) ``` #### device item doc **type** func **brief** Get display device path **return** display device path **static** False **C++ defination code**: ```cpp std::string device() ```"},"/maixpy/api/maix/peripheral/timer.html":{"title":"maix.peripheral.timer","content":" title: maix.peripheral.timer maix.peripheral.timer module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.peripheral.timer` to access this module. ## Module No module ## Enum ## Variable ## Function ## Class ### TIMER item doc **brief** Peripheral timer class **C++ defination code**: ```cpp class TIMER ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** TIMER constructor **static** False **C++ defination code**: ```cpp TIMER() ```"},"/maixpy/api/maix/peripheral/i2c.html":{"title":"maix.peripheral.i2c","content":" title: maix.peripheral.i2c maix.peripheral.i2c module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.peripheral.i2c` to access this module. ## Module No module ## Enum ## Variable ### SEVEN\\_BIT item doc **brief** 7 bit address mode **value** **0x1** **readonly** True **C++ defination code**: ```cpp const int SEVEN_BIT 0x1 ``` ### TEN\\_BIT item doc **brief** 10 bit address mode **value** **0x2** **readonly** True **C++ defination code**: ```cpp const int TEN_BIT 0x2 ``` ### MASTER item doc **brief** master mode **value** **0x4** **readonly** True **C++ defination code**: ```cpp const int MASTER 0x4 ``` ### SLAVE item doc **brief** slave mode **value** **0x8** **readonly** True **C++ defination code**: ```cpp const int SLAVE 0x8 ``` ### STANDARD\\_SPEED item doc **brief** standard speed mode **value** **0x10** **readonly** True **C++ defination code**: ```cpp const int STANDARD_SPEED 0x10 ``` ### FAST\\_SPEED item doc **brief** fast speed mode **value** **0x20** **readonly** True **C++ defination code**: ```cpp const int FAST_SPEED 0x20 ``` ## Function ## Class ### I2C item doc **brief** Peripheral i2c class **C++ defination code**: ```cpp class I2C ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** I2C Device constructor\\nthis constructor will be export to MaixPy as _maix.example.Example.__init__ **param** **id**: direction [in], i2c index, int type<br>**scl**: direction [in], sck pin of i2c, int type<br>**sda**: direction [in], sda pin of i2c, int type<br>**freq**: direction [in], i2c clock, int type<br>option:<br>in the i2c.STANDARD_SPEED mode, range is [0, 100000]<br>in the i2c.FAST_SPEED mode, range is [0, 400000]<br>default clock is 1, means use max clock<br>**mode**: direction [in], mode of i2c, int type.<br>option:<br>mode i2c.MASTER, means master mode<br>mode i2c.SLAVE, means slave mode<br>**bit**: direction [in], address length of i2c, int type.<br>option:<br>bit i2c.SEVEN_BIT, means 7 bit address mode<br>bit i2c.TEN_BIT, means 10 bit address mode<br>**speed_mode**: direction [in], speed mode of i2c, int type.<br>option:<br>speed_mode i2c.STANDARD_SPEED, means standard speed mode, up to 100kbit/s<br>speed_mode i2c.FAST_SPEED, means fast speed mode, up to 400kbit/s<br> **static** False **C++ defination code**: ```cpp I2C(int id, int scl, int sda, int freq 1, int mode 1, int bit 1, int speed_mode 1) ``` #### writeto item doc **type** func **brief** write data to i2c slave **param** **addr**: direction [in], i2c slave address, int type<br>**data**: direction [in], data to write, vector<unsigned char> type.<br>Note: The member range of the list is [0,255]<br> **return** if success, return 0, else return 1 **static** False **C++ defination code**: ```cpp int writeto(int addr, std::vector<unsigned char> data) ``` #### readfrom item doc **type** func **brief** read data from i2c slave **param** **addr**: direction [in], i2c slave address, int type<br>**len**: direction [in], data length to read, int type<br> **return** the list of data read from i2c slave, vector<unsigned char> type **static** False **C++ defination code**: ```cpp std::vector<unsigned char> readfrom(int addr, int len) ``` #### scan item doc **type** func **brief** scan all i2c address **return** the list of i2c address, vector<int> type **static** False **C++ defination code**: ```cpp std::vector<int> scan() ``` #### writeto\\_mem item doc **type** func **brief** write data to i2c slave **param** **addr**: direction [in], i2c slave address, int type<br>**start_addr**: direction [in], start address of i2c slave, int type<br>**data**: direction [in], data to write, vector<unsigned char> type.<br>Note: The member range of the list is [0,255]<br> **return** if success, return 0, else return 1 **static** False **C++ defination code**: ```cpp int writeto_mem(int addr, int start_addr, std::vector<unsigned char> data) ``` #### readfrom\\_mem item doc **type** func **brief** read data from i2c slave **param** **addr**: direction [in], i2c slave address, int type<br>**start_addr**: direction [in], start address of i2c slave, int type<br>**len**: direction [in], data length to read, int type<br> **return** the list of data read from i2c slave, vector<unsigned char> type **static** False **C++ defination code**: ```cpp std::vector<unsigned char> readfrom_mem(int addr, int start_addr, int len) ```"},"/maixpy/api/maix/peripheral/gpio.html":{"title":"maix.peripheral.gpio","content":" title: maix.peripheral.gpio maix.peripheral.gpio module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.peripheral.gpio` to access this module. ## Module No module ## Enum ## Variable ### IN item doc **brief** GPIO input mode **value** **0x01** **readonly** True **C++ defination code**: ```cpp const int IN 0x01 ``` ### OUT item doc **brief** GPIO output mode **value** **0x2** **readonly** True **C++ defination code**: ```cpp const int OUT 0x2 ``` ### OUT\\_OD item doc **brief** GPIO output open drain mode **value** **0x3** **readonly** True **C++ defination code**: ```cpp const int OUT_OD 0x3 ``` ### PULL\\_NONE item doc **brief** GPIO pull none mode **value** **0x4** **readonly** True **C++ defination code**: ```cpp const int PULL_NONE 0x4 ``` ### PULL\\_UP item doc **brief** GPIO pull up mode **value** **0x5** **readonly** True **C++ defination code**: ```cpp const int PULL_UP 0x5 ``` ### PULL\\_DOWN item doc **brief** GPIO pull down mode **value** **0x6** **readonly** True **C++ defination code**: ```cpp const int PULL_DOWN 0x6 ``` ### OFF item doc **brief** GPIO off **value** **0x0** **readonly** True **C++ defination code**: ```cpp const int OFF 0x0 ``` ### ON item doc **brief** GPIO on **value** **0x1** **readonly** True **C++ defination code**: ```cpp const int ON 0x1 ``` ## Function ## Class ### GPIO item doc **brief** Peripheral gpio class **C++ defination code**: ```cpp class GPIO ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** GPIO constructor **param** **pin**: direction [in], gpio pin. int type.<br>**mode**: direction [in], gpio mode. int type. default is 1, means gpio.IN<br>option:<br>mode gpio.IN, means input mode<br>mode gpio.OUT, means output mode<br>mode gpio.OUT_OD, means output open drain mode<br>**pull**: direction [in], gpio pull. int type. default is determined by actual board.<br>option:<br>pull gpio.PULL_NONE, means pull none mode<br>pull gpio.PULL_UP, means pull up mode<br>pull gpio.PULL_DOWN, means pull down mode<br> **static** False **C++ defination code**: ```cpp GPIO(int pin, int mode 1, int pull 1) ``` #### value item doc **type** func **brief** write/read gpio value **param** **value**: direction [in], gpio value. int type.<br>value 0, means write gpio to low level<br>value 1, means write gpio to high level<br> **return** int type<br>if success, return 0; else return 1 **static** False **C++ defination code**: ```cpp int value(int value 1) ``` #### write item doc **type** func **brief** get gpio write **param** **value**: direction [in], gpio value. int type.<br>value 0, means write gpio to low level<br>value 1, means write gpio to high level<br>value 1 or not set, means read gpio value<br> **return** int type<br>when read gpio value, return gpio value<br>when write gpio value, if success, return 0; else return 1 **static** False **C++ defination code**: ```cpp int write(int value) ``` #### read item doc **type** func **brief** get gpio read **return** int type<br>return 0, means gpio is low level<br>return 1, means gpio is high level<br>return other, means error **static** False **C++ defination code**: ```cpp int read() ``` #### on item doc **type** func **brief** set gpio on **static** False **C++ defination code**: ```cpp void on() ``` #### off item doc **type** func **brief** set gpio off **static** False **C++ defination code**: ```cpp void off() ``` #### high item doc **type** func **brief** set gpio high **static** False **C++ defination code**: ```cpp void high() ``` #### low item doc **type** func **brief** set gpio low **static** False **C++ defination code**: ```cpp void low() ``` #### toggle item doc **type** func **brief** gpio toggle **static** False **C++ defination code**: ```cpp void toggle() ```"},"/maixpy/api/maix/peripheral/uart.html":{"title":"maix.peripheral.uart","content":" title: maix.peripheral.uart maix uart peripheral driver > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.peripheral.uart` to access this module. ## Module No module ## Enum ### PARITY item doc **brief** uart parity enum **values** **PARITY_NONE**: no parity<br>**PARITY_ODD**: odd parity<br>**PARITY_EVEN**: even parity<br>**PARITY_MAX**: <br> **C++ defination code**: ```cpp enum PARITY { PARITY_NONE 0x00, // no parity PARITY_ODD 0x01, // odd parity PARITY_EVEN 0x02, // even parity PARITY_MAX } ``` ### STOP item doc **brief** uart stop bits **values** **STOP_1**: 1 stop bit<br>**STOP_2**: 2 stop bits<br>**STOP_1_5**: 1.5 stop bits<br>**STOP_MAX**: <br> **C++ defination code**: ```cpp enum STOP { STOP_1 0x01, // 1 stop bit STOP_2 0x02, // 2 stop bits STOP_1_5 0x03, // 1.5 stop bits STOP_MAX } ``` ### BITS item doc **brief** uart stop bits **values** **BITS_5**: 5 data bits<br>**BITS_6**: 6 data bits<br>**BITS_7**: 7 data bits<br>**BITS_8**: 8 data bits<br>**BITS_MAX**: <br> **C++ defination code**: ```cpp enum BITS { BITS_5 5, // 5 data bits BITS_6 6, // 6 data bits BITS_7 7, // 7 data bits BITS_8 8, // 8 data bits BITS_MAX } ``` ### FLOW\\_CTRL item doc **brief** uart flow control **values** **FLOW_CTRL_NONE**: no flow control<br>**FLOW_CTRL_HW**: hardware flow control<br>**FLOW_CTRL_MAX**: <br> **C++ defination code**: ```cpp enum FLOW_CTRL { FLOW_CTRL_NONE 0, // no flow control FLOW_CTRL_HW 1, // hardware flow control FLOW_CTRL_MAX } ``` ## Variable ## Function ### list\\_ports item doc **brief** Get supported uart ports. **return** uart ports list, string type. **C++ defination code**: ```cpp std::vector<std::string> list_ports() ``` ## Class ### UART item doc **brief** maix uart peripheral driver **C++ defination code**: ```cpp class UART : public comm::CommBase ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** UART constructor. You need to call open() to open the device. **param** **port**: uart port. string type, can get it by uart.list_ports().<br>If empty, will not open device in constructor, default empty.<br>if not empty, will auto open device in constructor, open fail will throw err.Exception.<br>**baudrate**: baudrate of uart. int type, default 115200.<br>**databits**: databits, values @see uart.DATA_BITS<br>**parity**: parity, values @see uart.PARITY<br>**stopbits**: stopbits, values @see uart.STOP_BITS<br>**flow_control**: flow_control, values @see uart.FLOW_CTRL<br> **static** False **C++ defination code**: ```cpp UART(const std::string &port \"\", int baudrate 115200, uart::BITS databits uart::BITS_8, uart::PARITY parity uart::PARITY_NONE, uart::STOP stopbits uart::STOP_1, uart::FLOW_CTRL flow_ctrl uart::FLOW_CTRL_NONE) ``` #### set\\_port item doc **type** func **brief** Set port **param** **port**: uart port. string type, can get it by uart.list_ports().<br> **return** set port error code, err.Err type. **static** False **C++ defination code**: ```cpp err::Err set_port(const std::string &port) ``` #### get\\_port item doc **type** func **brief** Get port **return** uart port, string type. **static** False **C++ defination code**: ```cpp std::string get_port() ``` #### set\\_baudrate item doc **type** func **brief** Set baud rate **param** **baudrate**: baudrate of uart. int type, default 115200.<br> **return** set baud rate error code, err.Err type. **static** False **C++ defination code**: ```cpp err::Err set_baudrate(int baudrate) ``` #### get\\_baudrate item doc **type** func **brief** Get baud rate **return** baud rate, int type. **static** False **C++ defination code**: ```cpp int get_baudrate() ``` #### open item doc **type** func **brief** Open uart device, before open, port must be set in constructor or by set_port().\\nIf already opened, do nothing and return err.ERR_NONE. **return** open device error code, err.Err type. **static** False **C++ defination code**: ```cpp err::Err open() ``` #### is\\_open item doc **type** func **brief** Check if device is opened. **return** true if opened, false if not opened. **static** False **C++ defination code**: ```cpp bool is_open() ``` #### close item doc **type** func **brief** Close uart device, if already closed, do nothing and return err.ERR_NONE. **return** close device error code, err.Err type. **static** False **C++ defination code**: ```cpp err::Err close() ``` #### write\\_str item doc **type** func **brief** Send string data **param** **str**: string data<br> **return** sent data length, < 0 means error, value is err.Err. **static** False **C++ defination code**: ```cpp int write_str(const std::string &str) ``` #### write item doc **type** func **brief** Send data to uart **param** **data**: direction [in], data to send, bytes type. If you want to send str type, use str.encode() to convert.<br> **return** sent length, int type, if < 0 means error, value is err.Err. **static** False **C++ defination code**: ```cpp int write(Bytes &data) ``` #### available item doc **type** func **brief** Check if data available or wait data available. **param** **timeout**: unit ms, timeout to wait data, default 0.<br>0 means check data available and return immediately,<br>> 0 means wait until data available or timeout.<br> 1 means wait until data available.<br> **return** available data number, 0 if timeout or no data, <0 if error, value is err.Err, can be err::ERR_IO， err::ERR_CANCEL, err::ERR_NOT_OPEN. **throw** err.Exception if fatal error. **static** False **C++ defination code**: ```cpp int available(int timeout 0) ``` #### read item doc **type** func **brief** Recv data from uart **param** **len**: max data length want to receive, default 1.<br> 1 means read data in uart receive buffer.<br>>0 means read len data want to receive.<br>other values is invalid.<br>**timeout**: unit ms, timeout to receive data, default 0.<br>0 means read data in uart receive buffer and return immediately,<br> 1 means block until read len data,<br>>0 means block until read len data or timeout.<br> **return** received data, bytes type.<br>Attention, you need to delete the returned object yourself in C++. **static** False **C++ defination code**: ```cpp Bytes *read(int len 1, int timeout 0) ``` #### readline item doc **type** func **brief** Read line from uart, that is read until '\\n' or '\\r\\n'. **param** **timeout**: unit ms, timeout to receive data, default 1 means block until read '\\n' or '\\r\\n'.<br>> 0 means block until read '\\n' or '\\r\\n' or timeout.<br> **return** received data, bytes type. If timeout will return the current received data despite not read '\\n' or '\\r\\n'.<br>e.g. If we want to read b'123\\n', but when we only read b'12', timeout, then return b'12'. **static** False **C++ defination code**: ```cpp Bytes *readline(int timeout 1) ```"},"/maixpy/api/maix/peripheral/key.html":{"title":"maix.peripheral.key","content":" title: maix.peripheral.key maix.peripheral.key module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.peripheral.key` to access this module. ## Module No module ## Enum ### Keys item doc **brief** Keys enum, id the same as linux input.h(input event codes.h) **values** **KEY_NONE**: <br>**KEY_ESC**: <br>**KEY_OK**: <br>**KEY_OPTION**: <br>**KEY_NEXT**: <br>**KEY_PREV**: <br> **C++ defination code**: ```cpp enum Keys{ KEY_NONE 0x000, KEY_ESC 0x001, KEY_OK 0x160, KEY_OPTION 0x165, KEY_NEXT 0x197, KEY_PREV 0x19c } ``` ### State item doc **brief** Key state enum **values** **KEY_RELEASED**: <br>**KEY_PRESSED**: <br> **C++ defination code**: ```cpp enum State{ KEY_RELEASED 0, KEY_PRESSED 1, } ``` ## Variable ## Function ### add\\_default\\_listener item doc **brief** Add default listener, if you want to exit app when press ok button, you can just call this function.\\nThis function is auto called in MaixPy' startup code, so you don't need to call it in MaixPy.\\nCreate Key object will auto call rm_default_listener() to cancel the default ok button function.\\nWhen ok button pressed, a SIGINT signal will be raise and call app.set_exit_flag(True). **C++ defination code**: ```cpp void add_default_listener() ``` ### rm\\_default\\_listener item doc **brief** Remove default listener, if you want to cancel the default ok button function(exit app), you can just call this function. **C++ defination code**: ```cpp void rm_default_listener() ``` ## Class ### Key item doc **brief** Key input class **C++ defination code**: ```cpp class Key ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Key Device constructor **param** **callback**: When key triggered and callback is not empty(empty In MaixPy is None, in C++ is nullptr),<br>callback will be called with args key(key.Keys) and value(key.State).<br>If set to null, you can get key value by read() function.<br>This callback called in a standalone thread, so you can block a while in callback, and you should be carefully when operate shared data.<br>**open**: auto open device in constructor, if false, you need call open() to open device<br> **static** False **C++ defination code**: ```cpp Key(std::function<void(int, int)> callback nullptr, bool open true) ``` #### open item doc **type** func **brief** Open(Initialize) key device, if already opened, will close first and then open. **return** err::Err type, err.Err.ERR_NONE means success **static** False **C++ defination code**: ```cpp err::Err open() ``` #### close item doc **type** func **brief** Close key device **return** err::Err type, err.Err.ERR_NONE means success **static** False **C++ defination code**: ```cpp err::Err close() ``` #### is\\_opened item doc **type** func **brief** Check key device is opened **return** bool type, true means opened, false means closed **static** False **C++ defination code**: ```cpp bool is_opened() ``` #### read item doc **type** func **brief** Read key input, and return key and value, if callback is set, DO NOT call this function manually. **return** list type, first is key(maix.key.Keys), second is value(maix.key.State), if no key input, return [0, 0] **throw** If read failed, will throw maix.err.Exception. **static** False **C++ defination code**: ```cpp std::pair<int, int> read() ```"},"/maixpy/api/maix/peripheral/adc.html":{"title":"maix.peripheral.adc","content":" title: maix.peripheral.adc maix.peripheral.adc module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.peripheral.adc` to access this module. ## Module No module ## Enum ## Variable ### RES\\_BIT\\_8 item doc **brief** 8 bit resolution, supported by the actual hardware **value** **0x1** **readonly** True **C++ defination code**: ```cpp const int RES_BIT_8 0x1 ``` ### RES\\_BIT\\_10 item doc **brief** 10 bit resolution, supported by the actual hardware **value** **0x2** **readonly** True **C++ defination code**: ```cpp const int RES_BIT_10 0x2 ``` ### RES\\_BIT\\_12 item doc **brief** 12 bit resolution, supported by the actual hardware **value** **0x3** **readonly** True **C++ defination code**: ```cpp const int RES_BIT_12 0x3 ``` ### RES\\_BIT\\_16 item doc **brief** 16 bit resolution, supported by the actual hardware **value** **0x4** **readonly** True **C++ defination code**: ```cpp const int RES_BIT_16 0x4 ``` ## Function ## Class ### ADC item doc **brief** Peripheral adc class **C++ defination code**: ```cpp class ADC ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** ADC constructor **param** **pin**: direction [in], adc pin, int type<br>**resolution**: direction [in], adc resolution. default is 1, means use default resolution<br>option:<br>resolution adc.RES_BIT_8, means 8 bit resolution<br>resolution adc.RES_BIT_10, means 10 bit resolution<br>resolution adc.RES_BIT_12, means 12 bit resolution<br>resolution adc.RES_BIT_16, means 16 bit resolution<br>the default resolution is determined by actual hardware.<br>**vref**: direction [in], adc refer voltage. default is 1, means use default refer voltage.<br>the default vref is determined by actual hardware. range: [0.0, 10.0]<br> **static** False **C++ defination code**: ```cpp ADC(int pin, int resolution 1, float vref 1) ``` #### read item doc **type** func **brief** read adc value **return** adc data, int type<br>if resolution is 8 bit, return value range is [0, 255]<br>if resolution is 10 bit, return value range is [0, 1023]<br>if resolution is 12 bit, return value range is [0, 4095]<br>if resolution is 16 bit, return value range is [0, 65535] **static** False **C++ defination code**: ```cpp int read() ``` #### read\\_vol item doc **type** func **brief** read adc voltage **return** adc voltage, float type。the range is [0.0, vref] **static** False **C++ defination code**: ```cpp float read_vol() ```"},"/maixpy/api/maix/peripheral/pwm.html":{"title":"maix.peripheral.pwm","content":" title: maix.peripheral.pwm maix.peripheral.pwm module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.peripheral.pwm` to access this module. ## Module No module ## Enum ## Variable ## Function ## Class ### PWM item doc **brief** Peripheral pwm class **C++ defination code**: ```cpp class PWM ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** PWM constructor **param** **pin**: direction [in], pwm pin. int type.<br>**freq**: direction [in], pwm frequency, unit: Hz. int type. default is 1000<br>**duty**: direction [in], pwm duty. int type. range is [0, 100], default is 1, means set duty to 50<br>note: you can not set duty and duty_val at the same time<br>**duty_val**: direction [in], pwm duty value, unit: us. int type. default is 1, means set duty_val to (1000000000 / freq) * 0.5<br>note: you can not set duty and duty_val at the same time<br>**align**: direction [in], pwm align. int type. default is 1<br>**sync**: direction [in], pwm sync. int type. default is false<br> **static** False **C++ defination code**: ```cpp PWM(int pin, int freq 1000, int duty 1, int duty_val 1, int align 1, bool sync false) ``` #### duty item doc **type** func **brief** set pwm duty **param** **duty**: direction [in], pwm duty. int type. default is 1<br>duty [0, 100], set duty<br>duty 1 or not set, return current duty<br> **return** int type<br>when get duty, return current duty<br>when set duty, if success, return 0; else return 1 **static** False **C++ defination code**: ```cpp int duty(int duty 1) ``` #### duty\\_val item doc **type** func **brief** set pwm duty value **param** **duty_val**: direction [in], pwm duty value. int type. default is 1<br>duty_val [0, 65535], set duty_val<br>duty_val 1 or not set, return current duty_val<br> **return** int type<br>when get duty_val, return current duty_val<br>when set duty_val, if success, return 0; else return 1 **static** False **C++ defination code**: ```cpp int duty_val(int duty_val 1) ``` #### freq item doc **type** func **brief** set pwm frequency **param** **freq**: direction [in], pwm frequency. int type. default is 1<br>freq > 0, set freq<br>freq 1 or not set, return current freq<br> **return** int type<br>when get freq, return current freq<br>when set freq, if success, return 0; else return 1 **static** False **C++ defination code**: ```cpp int freq(int freq 1) ``` #### enable item doc **type** func **brief** set pwm enable **param** **enable**: direction [in], pwm enable. int type. default is 1<br>enable 0, disable pwm<br>enable 1, enable pwm<br>enable 1 or not set, return current enable value<br> **return** int type<br>when get enable, return current enable value<br>when set enable, if success, return 0; else return 1 **static** False **C++ defination code**: ```cpp int enable(int enable 1) ```"},"/maixpy/api/maix/time.html":{"title":"maix.time","content":" title: maix.time maix.time module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.time` to access this module. ## Module No module ## Enum ## Variable ## Function ### time item doc **brief** Get current time in s **return** current time in s, double type **C++ defination code**: ```cpp double time() ``` ### time\\_ms item doc **brief** Get current time in ms **return** current time in ms, uint64_t type **C++ defination code**: ```cpp uint64_t time_ms() ``` ### time\\_s item doc **brief** Get current time in s **return** current time in s, uint64_t type **C++ defination code**: ```cpp uint64_t time_s() ``` ### time\\_us item doc **brief** Get current time in us **return** current time in us, uint64_t type **C++ defination code**: ```cpp uint64_t time_us() ``` ### time\\_diff item doc **brief** Calculate time difference **param** **last**: last time<br>**now**: current time<br> **return** time difference **C++ defination code**: ```cpp double time_diff(double last, double now 1) ``` ### sleep item doc **brief** Sleep seconds **param** **s**: seconds, double type<br> **C++ defination code**: ```cpp void sleep(double s) ``` ### sleep\\_ms item doc **brief** Sleep milliseconds **param** **ms**: milliseconds, uint64_t type<br> **C++ defination code**: ```cpp void sleep_ms(uint64_t ms) ``` ### sleep\\_us item doc **brief** Sleep microseconds **param** **us**: microseconds, uint64_t type<br> **C++ defination code**: ```cpp void sleep_us(uint64_t us) ``` ### now item doc **brief** Get current UTC date and time **return** current date and time, DateTime type **C++ defination code**: ```cpp time::DateTime *now() ``` ### localtime item doc **brief** Get local time **return** local time, DateTime type **C++ defination code**: ```cpp time::DateTime *localtime() ``` ### strptime item doc **brief** DateTime from string **param** **str**: date time string<br>**format**: date time format<br> **return** DateTime **C++ defination code**: ```cpp time::DateTime *strptime(const std::string &str, const std::string &format) ``` ### gmtime item doc **brief** timestamp to DateTime(time zone is UTC (value 0)) **param** **timestamp**: double timestamp<br> **return** DateTime **C++ defination code**: ```cpp time::DateTime *gmtime(double timestamp) ``` ## Class ### DateTime item doc **brief** Date and time class **C++ defination code**: ```cpp class DateTime ``` #### year item doc **type** var **brief** Year **static** False **readonly** False **C++ defination code**: ```cpp int year ``` #### month item doc **type** var **brief** Month, 1~12 **static** False **readonly** False **C++ defination code**: ```cpp int month ``` #### day item doc **type** var **brief** Day **static** False **readonly** False **C++ defination code**: ```cpp int day ``` #### hour item doc **type** var **brief** Hour **static** False **readonly** False **C++ defination code**: ```cpp int hour ``` #### minute item doc **type** var **brief** Minute **static** False **readonly** False **C++ defination code**: ```cpp int minute ``` #### second item doc **type** var **brief** Second **static** False **readonly** False **C++ defination code**: ```cpp int second ``` #### microsecond item doc **type** var **brief** Microsecond **static** False **readonly** False **C++ defination code**: ```cpp int microsecond ``` #### yearday item doc **type** var **brief** Year day **static** False **readonly** False **C++ defination code**: ```cpp int yearday ``` #### weekday item doc **type** var **brief** Weekday, 0 is Monday, 6 is Sunday **static** False **readonly** False **C++ defination code**: ```cpp int weekday ``` #### zone item doc **type** var **brief** Time zone **static** False **readonly** False **C++ defination code**: ```cpp float zone ``` #### zone\\_name item doc **type** var **brief** Time zone name **static** False **readonly** False **C++ defination code**: ```cpp std::string zone_name ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Constructor **param** **year**: year<br>**month**: month<br>**day**: day<br>**hour**: hour<br>**minute**: minute<br>**second**: second<br>**microsecond**: microsecond<br>**yearday**: year day<br>**weekday**: weekday<br>**zone**: time zone<br> **static** False **C++ defination code**: ```cpp DateTime(int year 0, int month 0, int day 0, int hour 0, int minute 0, int second 0, int microsecond 0, int yearday 0, int weekday 0, int zone 0) ``` #### strftime item doc **type** func **brief** Convert to string **return** date time string **static** False **C++ defination code**: ```cpp std::string strftime(const std::string &format) ``` #### timestamp item doc **type** func **brief** Convert to float timestamp **return** float timestamp **static** False **C++ defination code**: ```cpp double timestamp() ```"},"/maixpy/api/maix/fs.html":{"title":"maix.fs","content":" title: maix.fs maix.fs module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.fs` to access this module. ## Module No module ## Enum ### SEEK item doc **brief** SEEK enums **values** **SEEK_SET**: Seek from beginning of file.<br>**SEEK_CUR**: Seek from current position.<br>**SEEK_END**: Seek from end of file.<br> **C++ defination code**: ```cpp enum SEEK { SEEK_SET 0, // Seek from beginning of file. SEEK_CUR 1, // Seek from current position. SEEK_END 2, // Seek from end of file. } ``` ## Variable ## Function ### isabs item doc **brief** Check if the path is absolute path **param** **path**: path to check<br> **return** true if path is absolute path **C++ defination code**: ```cpp bool isabs(const std::string &path) ``` ### isdir item doc **brief** Check if the path is a directory, if not exist, throw exception **param** **path**: path to check<br> **return** true if path is a directory **C++ defination code**: ```cpp bool isdir(const std::string &path) ``` ### isfile item doc **brief** Check if the path is a file, if not exist, throw exception **param** **path**: path to check<br> **return** true if path is a file **C++ defination code**: ```cpp bool isfile(const std::string &path) ``` ### islink item doc **brief** Check if the path is a link, if not exist, throw exception **param** **path**: path to check<br> **return** true if path is a link **C++ defination code**: ```cpp bool islink(const std::string &path) ``` ### exists item doc **brief** Check if the path exists **param** **path**: path to check<br> **return** true if path exists **C++ defination code**: ```cpp bool exists(const std::string &path) ``` ### mkdir item doc **brief** Create a directory recursively **param** **path**: path to create<br>**exist_ok**: if true, also return true if directory already exists<br>**recursive**: if true, create directory recursively, otherwise, only create one directory, default is true<br> **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed **C++ defination code**: ```cpp err::Err mkdir(const std::string &path, bool exist_ok true, bool recursive true) ``` ### rmdir item doc **brief** Remove a directory **param** **path**: path to remove<br>**recursive**: if true, remove directory recursively, otherwise, only remove empty directory, default is false<br> **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed **C++ defination code**: ```cpp err::Err rmdir(const std::string &path, bool recursive false) ``` ### remove item doc **brief** Remove a file **param** **path**: path to remove<br> **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed **C++ defination code**: ```cpp err::Err remove(const std::string &path) ``` ### rename item doc **brief** Rename a file or directory **param** **src**: source path<br>**dst**: destination path, if destination dirs not exist, will auto create<br> **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed **C++ defination code**: ```cpp err::Err rename(const std::string &src, const std::string &dst) ``` ### getsize item doc **brief** Get file size **param** **path**: path to get size<br> **return** file size if success, err::Err code if failed **C++ defination code**: ```cpp int getsize(const std::string &path) ``` ### dirname item doc **brief** Get directory name of path **param** **path**: path to get dirname<br> **return** dirname if success, empty string if failed **C++ defination code**: ```cpp std::string dirname(const std::string &path) ``` ### basename item doc **brief** Get base name of path **param** **path**: path to get basename<br> **return** basename if success, empty string if failed **C++ defination code**: ```cpp std::string basename(const std::string &path) ``` ### abspath item doc **brief** Get absolute path **param** **path**: path to get absolute path<br> **return** absolute path if success, empty string if failed **C++ defination code**: ```cpp std::string abspath(const std::string &path) ``` ### getcwd item doc **brief** Get current working directory **return** current working directory absolute path **C++ defination code**: ```cpp std::string getcwd() ``` ### realpath item doc **brief** Get realpath of path **param** **path**: path to get realpath<br> **return** realpath if success, empty string if failed **C++ defination code**: ```cpp std::string realpath(const std::string &path) ``` ### splitext item doc **brief** Get file extension **param** **path**: path to get extension<br> **return** extension if success, empty string if failed **C++ defination code**: ```cpp std::string splitext(const std::string &path) ``` ### listdir item doc **brief** List files in directory **param** **path**: path to list<br>**recursive**: if true, list recursively, otherwise, only list current directory, default is false<br>**full_path**: if true, return full path, otherwise, only return basename, default is false<br> **return** files list if success, nullptr if failed **C++ defination code**: ```cpp std::vector<std::string> *listdir(const std::string &path, bool recursive false, bool full_path false) ``` ### open item doc **brief** Open a file, and return a File object **param** **path**: path to open<br>**mode**: open mode, support \"r\", \"w\", \"a\", \"r+\", \"w+\", \"a+\", \"rb\", \"wb\", \"ab\", \"rb+\", \"wb+\", \"ab+\"<br> **return** File object if success(need to delete object manually in C/C++), nullptr if failed **C++ defination code**: ```cpp fs::File *open(const std::string &path, const std::string &mode) ``` ### tempdir item doc **brief** Get temp files directory **return** temp files directory **C++ defination code**: ```cpp std::string tempdir() ``` ## Class ### File item doc **brief** File read write ops **C++ defination code**: ```cpp class File ``` #### open item doc **type** func **brief** Open a file **param** **path**: path to open<br>**mode**: open mode, support \"r\", \"w\", \"a\", \"r+\", \"w+\", \"a+\", \"rb\", \"wb\", \"ab\", \"rb+\", \"wb+\", \"ab+\"<br> **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed **static** False **C++ defination code**: ```cpp err::Err open(const std::string &path, const std::string &mode) ``` #### close item doc **type** func **brief** Close a file **static** False **C++ defination code**: ```cpp void close() ``` #### read item doc **type** func **brief** Read data from file API2 **param** **size**: max read size<br> **return** bytes data if success(need delete manually in C/C++), nullptr if failed **static** False **C++ defination code**: ```cpp std::vector<uint8_t> *read(int size) ``` #### readline item doc **type** func **brief** Read line from file **return** line if success, empty string if failed. You need to delete the returned object manually in C/C++. **static** False **C++ defination code**: ```cpp std::string *readline() ``` #### write item doc **type** func **brief** Write data to file API2 **param** **buf**: buffer to write<br> **return** write size if success, err::Err code if failed **static** False **C++ defination code**: ```cpp int write(const std::vector<uint8_t> &buf) ``` #### seek item doc **type** func **brief** Seek file position **param** **offset**: offset to seek<br>**whence**: @see maix.fs.SEEK<br> **return** new position if success, err::Err code if failed **static** False **C++ defination code**: ```cpp int seek(int offset, int whence) ``` #### tell item doc **type** func **brief** Get file position **return** file position if success, err::Err code if failed **static** False **C++ defination code**: ```cpp int tell() ``` #### flush item doc **type** func **brief** Flush file **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed **static** False **C++ defination code**: ```cpp err::Err flush() ```"},"/maixpy/api/maix/camera.html":{"title":"maix.camera","content":" title: maix.camera maix.camera module, access camera device and get image from it > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.camera` to access this module. ## Module No module ## Enum ## Variable ## Function ### list\\_devices item doc **brief** List all supported camera devices. **return** Returns the path to the camera device. **C++ defination code**: ```cpp std::vector<std::string> list_devices() ``` ### set\\_regs\\_enable item doc **brief** Enable set camera registers, default is false, if set to true, will not set camera registers, you can manually set registers by write_reg API. **param** **enable**: enable/disable set camera registers<br> **C++ defination code**: ```cpp void set_regs_enable(bool enable true) ``` ## Class ### Camera item doc **brief** Camera class **C++ defination code**: ```cpp class Camera ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Construct a new Camera object **param** **width**: camera width, default is 1, means auto, mostly means max width of camera support<br>**height**: camera height, default is 1, means auto, mostly means max height of camera support<br>**format**: camera output format, default is image.Format.FMT_RGB888<br>**device**: camera device path, you can get devices by list_devices method, by default(value is NULL(None in MaixPy)) means the first device<br>**fps**: camera fps, default is 1, means auto, mostly means max fps of camera support<br>**buff_num**: camera buffer number, default is 3, means 3 buffer, one used by user, one used for cache the next frame,<br>more than one buffer will accelerate image read speed, but will cost more memory.<br>**open**: If true, camera will automatically call open() after creation. default is true.<br> **static** False **C++ defination code**: ```cpp Camera(int width 1, int height 1, image::Format format image::FMT_RGB888, const char *device nullptr, int fps 1, int buff_num 3, bool open true) ``` #### get\\_ch\\_nums item doc **type** func **brief** Get the number of channels supported by the camera. **return** Returns the maximum number of channels. **static** False **C++ defination code**: ```cpp int get_ch_nums() ``` #### open item doc **type** func **brief** Open camera and run **param** **width**: camera width, default is 1, means auto, mostly means max width of camera support<br>**height**: camera height, default is 1, means auto, mostly means max height of camera support<br>**format**: camera output format, default same as the constructor's format argument<br>**fps**: camera fps, default is 1, means auto, mostly means max fps of camera support<br>**buff_num**: camera buffer number, default is 3, means 3 buffer, one used by user, one used for cache the next frame,<br>more than one buffer will accelerate image read speed, but will cost more memory.<br> **return** error code, err::ERR_NONE means success, others means failed **static** False **C++ defination code**: ```cpp err::Err open(int width 1, int height 1, image::Format format image::FMT_INVALID, int fps 1, int buff_num 1) ``` #### read item doc **type** func **brief** Get one frame image from camera buffer, must call open method before read.\\nIf open method not called, will call it automatically, if open failed, will throw exception!\\nSo call open method before read is recommended. **param** **buff**: buffer to store image data, if buff is nullptr, will alloc memory automatically.<br>In MaixPy, default to None, you can create a image.Image object, then pass img.data() to buff.<br>**block**: block read, default is true, means block util read image successfully,<br>if set to false, will return nullptr if no image in buffer<br> **return** image::Image object, if failed, return nullptr, you should delete if manually in C++ **static** False **C++ defination code**: ```cpp image::Image *read(void *buff nullptr, size_t buff_size 0, bool block true) ``` #### clear\\_buff item doc **type** func **brief** Clear buff to ensure the next read image is the latest image **static** False **C++ defination code**: ```cpp void clear_buff() ``` #### skip\\_frames item doc **type** func **brief** Read some frames and drop, this is usually used avoid read not stable image when camera just opened. **param** **num**: number of frames to read and drop<br> **static** False **C++ defination code**: ```cpp void skip_frames(int num) ``` #### close item doc **type** func **brief** Close camera **static** False **C++ defination code**: ```cpp void close() ``` #### add\\_channel item doc **type** func **brief** Add a new channel and return a new Camera object, you can use close() to close this channel. **param** **width**: camera width, default is 1, means auto, mostly means max width of camera support<br>**height**: camera height, default is 1, means auto, mostly means max height of camera support<br>**format**: camera output format, default is RGB888<br>**fps**: camera fps, default is 1, means auto, mostly means max fps of camera support<br>**buff_num**: camera buffer number, default is 3, means 3 buffer, one used by user, one used for cache the next frame,<br>more than one buffer will accelerate image read speed, but will cost more memory.<br>**open**: If true, camera will automatically call open() after creation. default is true.<br> **return** new Camera object **static** False **C++ defination code**: ```cpp camera::Camera *add_channel(int width 1, int height 1, image::Format format image::FMT_RGB888, int fps 1, int buff_num 3, bool open true) ``` #### is\\_opened item doc **type** func **brief** Check if camera is opened **return** true if camera is opened, false if not **static** False **C++ defination code**: ```cpp bool is_opened() ``` #### is\\_closed item doc **type** func **brief** check camera device is closed or not **return** closed or not, bool type **static** False **C++ defination code**: ```cpp bool is_closed() ``` #### width item doc **type** func **brief** Get camera width **return** camera width **static** False **C++ defination code**: ```cpp int width() ``` #### height item doc **type** func **brief** Get camera height **return** camera height **static** False **C++ defination code**: ```cpp int height() ``` #### fps item doc **type** func **brief** Get camera fps **return** camera fps **static** False **C++ defination code**: ```cpp int fps() ``` #### format item doc **type** func **brief** Get camera output format **return** camera output format, image::Format object **static** False **C++ defination code**: ```cpp image::Format format() ``` #### buff\\_num item doc **type** func **brief** Get camera buffer number **return** camera buffer number **static** False **C++ defination code**: ```cpp int buff_num() ``` #### hmirror item doc **type** func **brief** Get camera horizontal mirror **return** camera horizontal mirror **static** False **C++ defination code**: ```cpp int hmirror(int value 1) ``` #### vflip item doc **type** func **brief** Get camera vertical flip **return** camera vertical flip **static** False **C++ defination code**: ```cpp int vflip(int value 1) ``` #### exposure item doc **type** func **brief** Get camera exposure **return** camera exposure **static** False **C++ defination code**: ```cpp float exposure(int value 1) ``` #### gain item doc **type** func **brief** Get camera gain **return** camera gain **static** False **C++ defination code**: ```cpp float gain(int value 1) ``` #### device item doc **type** func **brief** Get camera device path **return** camera device path **static** False **C++ defination code**: ```cpp std::string device() ``` #### write\\_reg item doc **type** func **brief** Write camera register **param** **addr**: register address<br>**data**: register data<br>**bit_width**: register data bit width, default is 8<br> **return** error code, err::ERR_NONE means success, others means failed **static** False **C++ defination code**: ```cpp err::Err write_reg(int addr, int data, int bit_width 8) ``` #### read\\_reg item doc **type** func **brief** Read camera register **param** **addr**: register address<br>**bit_width**: register data bit width, default is 8<br> **return** register data, 1 means failed **static** False **C++ defination code**: ```cpp int read_reg(int addr, int bit_width 8) ``` #### show\\_colorbar item doc **type** func **brief** Camera output color bar image for test **param** **enable**: enable/disable color bar<br> **return** error code, err::ERR_NONE means success, others means failed **static** False **C++ defination code**: ```cpp err::Err show_colorbar(bool enable) ```"},"/maixpy/api/maix/nn.html":{"title":"maix.nn","content":" title: maix.nn maix.nn module > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.nn` to access this module. ## Module module brief [F](./nn/F.html) maix.nn.F module ## Enum ## Variable ## Function ## Class ### YOLOv5 item doc **brief** YOLOv5 class **C++ defination code**: ```cpp class YOLOv5 ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Constructor of YOLOv5 class **param** **model**: model path, default empty, you can load model later by load function.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False **C++ defination code**: ```cpp YOLOv5(const string &model \"\") ``` #### load item doc **type** func **brief** Load model from file **param** **model**: Model path want to load<br> **return** err::Err **static** False **C++ defination code**: ```cpp err::Err load(const string &model) ``` #### detect item doc **type** func **brief** Detect objects from image **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**conf_th**: Confidence threshold, default 0.5.<br>**iou_th**: IoU threshold, default 0.45.<br>**fit**: Resize method, default image.Fit.FIT_CONTAIN.<br> **throw** If image format not match model input format, will throw err::Exception. **return** Object list. In C++, you should delete it after use. **static** False **C++ defination code**: ```cpp std::vector<nn::Object> *detect(image::Image &img, float conf_th 0.5, float iou_th 0.45, maix::image::Fit fit maix::image::FIT_CONTAIN) ``` #### input\\_size item doc **type** func **brief** Get model input size **return** model input size **static** False **C++ defination code**: ```cpp image::Size input_size() ``` #### input\\_width item doc **type** func **brief** Get model input width **return** model input size of width **static** False **C++ defination code**: ```cpp int input_width() ``` #### input\\_height item doc **type** func **brief** Get model input height **return** model input size of height **static** False **C++ defination code**: ```cpp int input_height() ``` #### input\\_format item doc **type** func **brief** Get input image format **return** input image format, image::Format type. **static** False **C++ defination code**: ```cpp image::Format input_format() ``` #### labels item doc **type** var **brief** Labels list **static** False **readonly** False **C++ defination code**: ```cpp std::vector<string> labels ``` #### label\\_path item doc **type** var **brief** Label file path **static** False **readonly** False **C++ defination code**: ```cpp std::string label_path ``` #### mean item doc **type** var **brief** Get mean value, list type **static** False **readonly** False **C++ defination code**: ```cpp std::vector<float> mean ``` #### scale item doc **type** var **brief** Get scale value, list type **static** False **readonly** False **C++ defination code**: ```cpp std::vector<float> scale ``` #### anchors item doc **type** var **brief** Get anchors **static** False **readonly** False **C++ defination code**: ```cpp std::vector<float> anchors ``` ### Classifier item doc **brief** Classifier **C++ defination code**: ```cpp class Classifier ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Construct a new Classifier object **param** **model**: MUD model path, if empty, will not load model, you can call load() later.<br>if not empty, will load model and will raise err::Exception if load failed.<br> **static** False **C++ defination code**: ```cpp Classifier(const string &model \"\") ``` #### load item doc **type** func **brief** Load model from file, model format is .mud,\\nMUD file should contain [extra] section, have key values:\\n model_type: classifier\\n input_type: rgb or bgr\\n mean: 123.675, 116.28, 103.53\\n scale: 0.017124753831663668, 0.01750700280112045, 0.017429193899782137\\n labels: imagenet_classes.txt **param** **model**: MUD model path<br> **return** error code, if load failed, return error code **static** False **C++ defination code**: ```cpp err::Err load(const string &model) ``` #### classify item doc **type** func **brief** Forward image to model, get result. Only for image input, use classify_raw for tensor input. **param** **img**: image, format should match model input_type， or will raise err.Exception<br>**softmax**: if true, will do softmax to result, or will return raw value<br> **throw** If error occurred, will raise err::Exception, you can find reason in log, mostly caused by args error or hardware error. **return** result, a list of (label, score). In C++, you need to delete it after use. **static** False **C++ defination code**: ```cpp std::vector<std::pair<int, float>> *classify(image::Image &img, bool softmax true) ``` #### classify\\_raw item doc **type** func **brief** Forward tensor data to model, get result **param** **data**: tensor data, format should match model input_type， or will raise err.Excetion<br>**softmax**: if true, will do softmax to result, or will return raw value<br> **throw** If error occurred, will raise err::Exception, you can find reason in log, mostly caused by args error or hardware error. **return** result, a list of (label, score). In C++, you need to delete it after use. **static** False **C++ defination code**: ```cpp std::vector<std::pair<int, float>> *classify_raw(tensor::Tensor &data, bool softmax true) ``` #### input\\_size item doc **type** func **brief** Get model input size, only for image input **return** model input size **static** False **C++ defination code**: ```cpp image::Size input_size() ``` #### input\\_width item doc **type** func **brief** Get model input width, only for image input **return** model input size of width **static** False **C++ defination code**: ```cpp int input_width() ``` #### input\\_height item doc **type** func **brief** Get model input height, only for image input **return** model input size of height **static** False **C++ defination code**: ```cpp int input_height() ``` #### input\\_format item doc **type** func **brief** Get input image format, only for image input **return** input image format, image::Format type. **static** False **C++ defination code**: ```cpp image::Format input_format() ``` #### input\\_shape item doc **type** func **brief** Get input shape, if have multiple input, only return first input shape **return** input shape, list type **static** False **C++ defination code**: ```cpp std::vector<int> input_shape() ``` #### labels item doc **type** var **brief** Labels list **static** False **readonly** False **C++ defination code**: ```cpp std::vector<string> labels ``` #### label\\_path item doc **type** var **brief** Label file path **static** False **readonly** False **C++ defination code**: ```cpp std::string label_path ``` #### mean item doc **type** var **brief** Get mean value, list type **static** False **readonly** False **C++ defination code**: ```cpp std::vector<float> mean ``` #### scale item doc **type** var **brief** Get scale value, list type **static** False **readonly** False **C++ defination code**: ```cpp std::vector<float> scale ``` ### MUD item doc **brief** MUD(model universal describe file) class **C++ defination code**: ```cpp class MUD ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** MUD constructor **param** **model_path**: direction [in], model file path, model format can be MUD(model universal describe file) file.<br>If model_path set, will load model from file, load failed will raise err.Exception.<br>If model_path not set, you can load model later by load function.<br> **static** False **C++ defination code**: ```cpp MUD(const char *model_path nullptr) ``` #### load item doc **type** func **brief** Load model from file **param** **model_path**: direction [in], model file path, model format can be MUD(model universal describe file) file.<br> **return** error code, if load success, return err::ERR_NONE **static** False **C++ defination code**: ```cpp err::Err load(const std::string &model_path) ``` #### type item doc **type** var **brief** Model type, string type **static** False **readonly** False **C++ defination code**: ```cpp std::string type ``` #### items item doc **type** var **brief** Model config items, different model type has different config items **static** False **readonly** False **C++ defination code**: ```cpp std::map<std::string, std::map<std::string, std::string>> items ``` ### LayerInfo item doc **brief** NN model layer info **C++ defination code**: ```cpp class LayerInfo ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** LayerInfo constructor **param** **name**: direction [in], layer name<br>**dtype**: direction [in], layer data type<br>**shape**: direction [in], layer shape<br> **static** False **C++ defination code**: ```cpp LayerInfo(const std::string &name \"\", tensor::DType dtype tensor::DType::FLOAT32, std::vector<int> shape std::vector<int>()) ``` #### name item doc **type** var **brief** Layer name **static** False **readonly** False **C++ defination code**: ```cpp std::string name ``` #### dtype item doc **type** var **brief** Layer data type **attention** If model is quantized, this is the real quantized data type like int8 float16,<br>in most scene, inputs and outputs we actually use float32 in API like forward. **static** False **readonly** False **C++ defination code**: ```cpp tensor::DType dtype ``` #### shape item doc **type** var **brief** Layer shape **static** False **readonly** False **C++ defination code**: ```cpp std::vector<int> shape ``` #### to\\_str item doc **type** func **brief** To string **static** False **C++ defination code**: ```cpp std::string to_str() ``` #### \\_\\_str\\_\\_ item doc **type** func **brief** To string **static** False **C++ defination code**: ```cpp std::string __str__() ``` ### NN item doc **brief** Neural network class **C++ defination code**: ```cpp class NN ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Neural network constructor **param** **model**: direction [in], model file path, model format can be MUD(model universal describe file) file.<br>If model_path set, will load model from file, load failed will raise err.Exception.<br>If model_path not set, you can load model later by load function.<br> **static** False **C++ defination code**: ```cpp NN(const std::string &model \"\") ``` #### load item doc **type** func **brief** Load model from file **param** **model**: direction [in], model file path, model format can be MUD(model universal describe file) file.<br> **return** error code, if load success, return err::ERR_NONE **static** False **C++ defination code**: ```cpp err::Err load(const std::string &model) ``` #### loaded item doc **type** func **brief** Is model loaded **return** true if model loaded, else false **static** False **C++ defination code**: ```cpp bool loaded() ``` #### inputs\\_info item doc **type** func **brief** Get model input layer info **return** input layer info **static** False **C++ defination code**: ```cpp std::vector<nn::LayerInfo> inputs_info() ``` #### outputs\\_info item doc **type** func **brief** Get model output layer info **return** output layer info **static** False **C++ defination code**: ```cpp std::vector<nn::LayerInfo> outputs_info() ``` #### extra\\_info item doc **type** func **brief** Get model extra info define in MUD file **return** extra info, dict type, key value object, attention: key and value are all string type. **static** False **C++ defination code**: ```cpp std::map<std::string, std::string> extra_info() ``` #### forward item doc **type** func **brief** forward run model, get output of model,\\nthis is specially for MaixPy, not efficient, but easy to use in MaixPy **param** **input**: direction [in], input tensor<br> **return** output tensor. In C++, you should manually delete tensors in return value and return value. **static** False **C++ defination code**: ```cpp tensor::Tensors *forward(tensor::Tensors &inputs) ``` #### forward\\_image item doc **type** func **brief** forward model, param is image **param** **img**: input image<br>**mean**: mean value, a list type, e.g. [0.485, 0.456, 0.406], default is empty list means not normalize.<br>**scale**: scale value, a list type, e.g. [1/0.229, 1/0.224, 1/0.225], default is empty list means not normalize.<br>**fit**: fit mode, if the image size of input not equal to model's input, it will auto resize use this fit method,<br>default is image.Fit.FIT_FILL for easy coordinate calculation, but for more accurate result, use image.Fit.FIT_CONTAIN is better.<br> **return** output tensor. In C++, you should manually delete tensors in return value and return value. **static** False **C++ defination code**: ```cpp tensor::Tensors *forward_image(image::Image &img, std::vector<float> mean std::vector<float>(), std::vector<float> scale std::vector<float>(), image::Fit fit image::Fit::FIT_FILL) ``` ### Object item doc **brief** Object for detect result **C++ defination code**: ```cpp class Object ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Constructor of Object for detect result **param** **x**: left top x<br>**y**: left top y<br>**w**: width<br>**h**: height<br>**class_id**: class id<br>**score**: score<br> **static** False **C++ defination code**: ```cpp Object(int x 0, int y 0, int w 0, int h 0, int class_id 0, float score 0) ``` #### \\_\\_str\\_\\_ item doc **type** func **brief** Object info to string **return** Object info string **static** False **C++ defination code**: ```cpp std::string to_str() ``` #### x item doc **type** var **brief** Object left top coordinate x **static** False **readonly** False **C++ defination code**: ```cpp int x ``` #### y item doc **type** var **brief** Object left top coordinate y **static** False **readonly** False **C++ defination code**: ```cpp int y ``` #### w item doc **type** var **brief** Object width **static** False **readonly** False **C++ defination code**: ```cpp int w ``` #### h item doc **type** var **brief** Object height **static** False **readonly** False **C++ defination code**: ```cpp int h ``` #### class\\_id item doc **type** var **brief** Object class id **static** False **readonly** False **C++ defination code**: ```cpp int class_id ``` #### score item doc **type** var **brief** Object score **static** False **readonly** False **C++ defination code**: ```cpp float score ```"},"/maixpy/api/maix/image.html":{"title":"maix.image","content":" title: maix.image maix.image module, image related definition and functions > This module is generated from [MaixCDK](https://github.com/sipeed/MaixCDK) > You can use `maix.image` to access this module. ## Module No module ## Enum ### Format item doc **brief** Image formats **attention** for developers, update this enum will also need to update the fmt_size in maix_image.cpp **values** **FMT_RGB888**: RGBRGB...RGB, R at the lowest address<br>**FMT_BGR888**: BGRBGR...BGR, B at the lowest address<br>**FMT_RGBA8888**: RGBARGBA...RGBA, R at the lowest address<br>**FMT_BGRA8888**: BGRABGRA...BGRA, B at the lowest address<br>**FMT_RGB565**: <br>**FMT_BGR565**: <br>**FMT_YUV422SP**: YYY...UVUVUV...UVUV<br>**FMT_YUV422P**: YYY...UUU...VVV<br>**FMT_YVU420SP**: YYY...VUVUVU...VUVU, NV21<br>**FMT_YUV420SP**: YYY...UVUVUV...UVUV, NV12<br>**FMT_YVU420P**: YYY...VVV...UUU<br>**FMT_YUV420P**: YYY...UUU...VVV<br>**FMT_GRAYSCALE**: <br>**FMT_UNCOMPRESSED_MAX**: <br>**FMT_COMPRESSED_MIN**: <br>**FMT_JPEG**: <br>**FMT_PNG**: <br>**FMT_COMPRESSED_MAX**: <br>**FMT_INVALID**: format not valid<br> **C++ defination code**: ```cpp enum Format { FMT_RGB888 0, // RGBRGB...RGB, R at the lowest address FMT_BGR888, // BGRBGR...BGR, B at the lowest address FMT_RGBA8888, // RGBARGBA...RGBA, R at the lowest address FMT_BGRA8888, // BGRABGRA...BGRA, B at the lowest address FMT_RGB565, FMT_BGR565, FMT_YUV422SP, // YYY...UVUVUV...UVUV FMT_YUV422P, // YYY...UUU...VVV FMT_YVU420SP, // YYY...VUVUVU...VUVU, NV21 FMT_YUV420SP, // YYY...UVUVUV...UVUV, NV12 FMT_YVU420P, // YYY...VVV...UUU FMT_YUV420P, // YYY...UUU...VVV FMT_GRAYSCALE, FMT_UNCOMPRESSED_MAX, // compressed format below, not compressed should define upper FMT_COMPRESSED_MIN, FMT_JPEG, FMT_PNG, FMT_COMPRESSED_MAX, FMT_INVALID 0xFF // format not valid } ``` ### Fit item doc **brief** Object fit method **values** **FIT_NONE**: no object fit, keep original<br>**FIT_FILL**: width to new width, height to new height, may be stretch<br>**FIT_CONTAIN**: keep aspect ratio, fill blank area with black color<br>**FIT_COVER**: keep aspect ratio, crop image to fit new size<br>**FIT_MAX**: <br> **C++ defination code**: ```cpp enum Fit { FIT_NONE 1, // no object fit, keep original FIT_FILL 0, // width to new width, height to new height, may be stretch FIT_CONTAIN, // keep aspect ratio, fill blank area with black color FIT_COVER, // keep aspect ratio, crop image to fit new size FIT_MAX } ``` ### ResizeMethod item doc **brief** Resize method **values** **NEAREST**: <br>**BILINEAR**: <br>**BICUBIC**: <br>**AREA**: <br>**LANCZOS**: <br>**HAMMING**: <br>**RESIZE_METHOD_MAX**: <br> **C++ defination code**: ```cpp enum ResizeMethod { NEAREST 0, BILINEAR, BICUBIC, AREA, LANCZOS, HAMMING, RESIZE_METHOD_MAX } ``` ### ApriltagFamilies item doc **brief** Family of apriltag **values** **TAG16H5**: <br>**TAG25H7**: <br>**TAG25H9**: <br>**TAG36H10**: <br>**TAG36H11**: <br>**ARTOOLKIT**: <br> **C++ defination code**: ```cpp enum ApriltagFamilies { TAG16H5 1, TAG25H7 2, TAG25H9 4, TAG36H10 8, TAG36H11 16, ARTOOLKIT 32 } ``` ### TemplateMatch item doc **brief** Template match method **values** **SEARCH_EX**: Exhaustive search<br>**SEARCH_DS**: Diamond search<br> **C++ defination code**: ```cpp enum TemplateMatch { SEARCH_EX, // Exhaustive search SEARCH_DS, // Diamond search } ``` ### CornerDetector item doc **brief** CornerDetector class **values** **CORNER_FAST**: <br>**CORNER_AGAST**: <br> **C++ defination code**: ```cpp enum CornerDetector { CORNER_FAST, CORNER_AGAST } ``` ### EdgeDetector item doc **brief** EdgeDetector class **values** **EDGE_CANNY**: <br>**EDGE_SIMPLE**: <br> **C++ defination code**: ```cpp enum EdgeDetector { EDGE_CANNY, EDGE_SIMPLE, } ``` ## Variable ### fmt\\_size item doc **brief** Image format size in bytes **attention** It's a copy of this variable in MaixPy,<br>so change it in C++ (e.g. update var in hello function) will not take effect the var inMaixPy.<br>So we add const for this var to avoid this mistake. **value** **{<br> 3,<br> 3,<br> 4,<br> 4,<br> 2,<br> 2,<br> 2,<br> 2,<br> 1.5,<br> 1.5,<br> 1.5,<br> 1.5,<br> 1,<br> 0,<br> 0,<br> 0,<br> 0,<br> 0<br> }** **readonly** True **C++ defination code**: ```cpp const std::vector<float> fmt_size { 3, 3, 4, 4, 2, 2, 2, 2, 1.5, 1.5, 1.5, 1.5, 1, 0, 0, 0, 0, 0 } ``` ### fmt\\_names item doc **brief** Image format string **value** **{<br> \"RGB888\",<br> \"BGR888\",<br> \"RGBA8888\",<br> \"BGRA8888\",<br> \"RGB565\",<br> \"BGR565\",<br> \"YUV422SP\",<br> \"YUV422P\",<br> \"YVU420SP\",<br> \"YUV420SP\",<br> \"YVU420P\"<br> \"YUV420P\",<br> \"GRAYSCALE\",<br> \"MAX\"}** **readonly** True **C++ defination code**: ```cpp const std::vector<std::string> fmt_names { \"RGB888\", \"BGR888\", \"RGBA8888\", \"BGRA8888\", \"RGB565\", \"BGR565\", \"YUV422SP\", \"YUV422P\", \"YVU420SP\", \"YUV420SP\", \"YVU420P\" \"YUV420P\", \"GRAYSCALE\", \"MAX\"} ``` ### COLOR\\_WHITE item doc **brief** Predefined color white **value** **image::Color::from_rgb(255, 255, 255)** **readonly** True **C++ defination code**: ```cpp const image::Color COLOR_WHITE image::Color::from_rgb(255, 255, 255) ``` ### COLOR\\_BLACK item doc **brief** Predefined color black **value** **image::Color::from_rgb(0, 0, 0)** **readonly** True **C++ defination code**: ```cpp const image::Color COLOR_BLACK image::Color::from_rgb(0, 0, 0) ``` ### COLOR\\_RED item doc **brief** Predefined color red **value** **image::Color::from_rgb(255, 0, 0)** **readonly** True **C++ defination code**: ```cpp const image::Color COLOR_RED image::Color::from_rgb(255, 0, 0) ``` ### COLOR\\_GREEN item doc **brief** Predefined color green **value** **image::Color::from_rgb(0, 255, 0)** **readonly** True **C++ defination code**: ```cpp const image::Color COLOR_GREEN image::Color::from_rgb(0, 255, 0) ``` ### COLOR\\_BLUE item doc **brief** Predefined color blue **value** **image::Color::from_rgb(0, 0, 255)** **readonly** True **C++ defination code**: ```cpp const image::Color COLOR_BLUE image::Color::from_rgb(0, 0, 255) ``` ### COLOR\\_YELLOW item doc **brief** Predefined color yellow **value** **image::Color::from_rgb(255, 255, 0)** **readonly** True **C++ defination code**: ```cpp const image::Color COLOR_YELLOW image::Color::from_rgb(255, 255, 0) ``` ### COLOR\\_PURPLE item doc **brief** Predefined color purple **value** **image::Color::from_rgb(143, 0, 255)** **readonly** True **C++ defination code**: ```cpp const image::Color COLOR_PURPLE image::Color::from_rgb(143, 0, 255) ``` ### COLOR\\_ORANGE item doc **brief** Predefined color orange **value** **image::Color::from_rgb(255, 127, 0)** **readonly** True **C++ defination code**: ```cpp const image::Color COLOR_ORANGE image::Color::from_rgb(255, 127, 0) ``` ### COLOR\\_GRAY item doc **brief** Predefined color gray **value** **image::Color::from_rgb(127, 127, 127)** **readonly** True **C++ defination code**: ```cpp const image::Color COLOR_GRAY image::Color::from_rgb(127, 127, 127) ``` ## Function ### load item doc **brief** Load image from file, and convert to Image object **param** **path**: image file path<br>**format**: read as this format, if not match, will convert to this format, by default is RGB888<br> **return** Image object **C++ defination code**: ```cpp image::Image *load(const char *path, image::Format format image::Format::FMT_RGB888) ``` ### load\\_font item doc **brief** Load font from file **param** **name**: font name, used to identify font<br>**path**: font file path, support ttf, ttc, otf<br>**size**: font size, font height, by default is 16<br> **return** error code, err::ERR_NONE is ok, other is error **C++ defination code**: ```cpp err::Err load_font(const std::string &name, const char *path, int size 16) ``` ### set\\_default\\_font item doc **brief** Set default font, if not call this method, default is hershey_plain **param** **name**: font name, supported names can be get by fonts()<br> **return** error code, err::ERR_NONE is ok, other is error **C++ defination code**: ```cpp err::Err set_default_font(const std::string &name) ``` ### fonts item doc **brief** Get all loaded fonts **return** all loaded fonts, string list type **C++ defination code**: ```cpp std::vector<std::string> *fonts() ``` ### text\\_size item doc **brief** Get text rendered width and height **param** **text**: text content<br>**scale**: font scale, by default(value is 1)<br>**thickness**: text thickness(line width), by default(value is 1)<br> **return** text rendered width and height, [width, height] **C++ defination code**: ```cpp image::Size text_size(std::string text, float scale 1, int thickness 1, const std::string &font \"\") ``` ### cv2image item doc **brief** OpenCV Mat(numpy array object) to Image object **param** **array**: numpy array object, must be a 3 dim or 2 dim continuous array with shape hwc or hw<br> **return** Image object **C++ defination code**: ```cpp image::Image *cv2image(py::array_t<uint8_t, py::array::c_style> array, bool bgr true, bool copy true) ``` ### image2cv item doc **brief** Image object to OpenCV Mat(numpy array object) **param** **img**: Image object<br> **return** numpy array object **C++ defination code**: ```cpp py::array_t<uint8_t, py::array::c_style> image2cv(image::Image *img, bool bgr true, bool copy true) ``` ## Class ### Size item doc **brief** Image size type **C++ defination code**: ```cpp class Size ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Construct a new Size object **param** **width**: image width<br>**height**: image height<br> **static** False **C++ defination code**: ```cpp Size(int width 0, int height 0) ``` #### width item doc **type** var **brief** width of size **static** False **readonly** False **C++ defination code**: ```cpp int width ``` #### height item doc **type** var **brief** height of size **static** False **readonly** False **C++ defination code**: ```cpp int height ``` #### \\_\\_getitem\\_\\_ item doc **type** func **brief** Subscript operator **param** **index**: 0 for width, 1 for height<br> **return** int& width or height **static** False **C++ defination code**: ```cpp int &__getitem__(int index) ``` #### \\_\\_str\\_\\_ item doc **type** func **brief** to string **static** False **C++ defination code**: ```cpp std::string __str__() ``` ### Line item doc **brief** Line class **C++ defination code**: ```cpp class Line ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Line constructor **param** **x1**: coordinate x1 of the straight line<br>**y1**: coordinate y1 of the straight line<br>**x2**: coordinate x2 of the straight line<br>**y2**: coordinate y2 of the straight line<br>**magnitude**: magnitude of the straight line after Hough transformation<br>**theta**: angle of the straight line after Hough transformation<br>**rho**: p value of the straight line after Hough transformation<br> **static** False **C++ defination code**: ```cpp Line(int x1, int y1, int x2, int y2, int magnitude 0, int theta 0, int rho 0) ``` #### x1 item doc **type** func **brief** get x1 of line **return** return x1 of the line, type is int **static** False **C++ defination code**: ```cpp int x1() ``` #### y1 item doc **type** func **brief** get y1 of line **return** return y1 of the line, type is int **static** False **C++ defination code**: ```cpp int y1() ``` #### x2 item doc **type** func **brief** get x2 of line **return** return x2 of the line, type is int **static** False **C++ defination code**: ```cpp int x2() ``` #### y2 item doc **type** func **brief** get y2 of line **return** return y2 of the line, type is int **static** False **C++ defination code**: ```cpp int y2() ``` #### length item doc **type** func **brief** get length of line **return** return length of the line, type is int **static** False **C++ defination code**: ```cpp int length() ``` #### magnitude item doc **type** func **brief** get magnitude of the straight line after Hough transformation **return** return magnitude, type is int **static** False **C++ defination code**: ```cpp int magnitude() ``` #### theta item doc **type** func **brief** get angle of the straight line after Hough transformation (0 179 degrees) **return** return angle, type is int **static** False **C++ defination code**: ```cpp int theta() ``` #### rho item doc **type** func **brief** get p value of the straight line after Hough transformation **return** return p value, type is int **static** False **C++ defination code**: ```cpp int rho() ``` ### Rect item doc **brief** Rect class **C++ defination code**: ```cpp class Rect ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Rect constructor **param** **corners**: corners of rect<br>**x**: coordinate x of the straight line<br>**y**: coordinate y of the straight line<br>**w**: coordinate w of the straight line<br>**h**: coordinate h of the straight line<br>**magnitude**: magnitude of the straight line after Hough transformation<br> **static** False **C++ defination code**: ```cpp Rect(std::vector<std::vector<int>> &corners, int x, int y, int w, int h, int magnitude 0) ``` #### corners item doc **type** func **brief** get corners of rect **return** return the coordinate of the rect. **static** False **C++ defination code**: ```cpp std::vector<std::vector<int>> corners() ``` #### rect item doc **type** func **brief** get rectangle of rect **return** return the rectangle of the rect. format is {x, y, w, h}, type is std::vector<int> **static** False **C++ defination code**: ```cpp std::vector<int> rect() ``` #### x item doc **type** func **brief** get x of rect **return** return x of the rect, type is int **static** False **C++ defination code**: ```cpp int x() ``` #### y item doc **type** func **brief** get y of rect **return** return y of the rect, type is int **static** False **C++ defination code**: ```cpp int y() ``` #### w item doc **type** func **brief** get w of rect **return** return w of the rect, type is int **static** False **C++ defination code**: ```cpp int w() ``` #### h item doc **type** func **brief** get h of rect **return** return h of the rect, type is int **static** False **C++ defination code**: ```cpp int h() ``` #### magnitude item doc **type** func **brief** get magnitude of the straight line after Hough transformation **return** return magnitude, type is int **static** False **C++ defination code**: ```cpp int magnitude() ``` ### Circle item doc **brief** circle class **C++ defination code**: ```cpp class Circle ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Circle constructor **param** **x**: coordinate x of the circle<br>**y**: coordinate y of the circle<br>**r**: coordinate r of the circle<br>**magnitude**: coordinate y2 of the straight line<br> **static** False **C++ defination code**: ```cpp Circle(int x, int y, int r, int magnitude) ``` #### x item doc **type** func **brief** get x of circle **return** return x of the circle, type is int **static** False **C++ defination code**: ```cpp int x() ``` #### y item doc **type** func **brief** get y of circle **return** return y of the circle, type is int **static** False **C++ defination code**: ```cpp int y() ``` #### r item doc **type** func **brief** get r of circle **return** return r of the circle, type is int **static** False **C++ defination code**: ```cpp int r() ``` #### magnitude item doc **type** func **brief** get magnitude of the circle after Hough transformation **return** return magnitude, type is int **static** False **C++ defination code**: ```cpp int magnitude() ``` ### Blob item doc **brief** Blob class **C++ defination code**: ```cpp class Blob ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Blob constructor **param** **rect**: blob rect, type is std::vector<int><br>**corners**: blob corners, type is std::vector<std::vector<int>><br>**mini_corners**: blob mini_corners, type is std::vector<std::vector<int>><br>**cx**: blob center x, type is float<br>**cy**: blob center y, type is float<br>**pixels**: blob pixels, type is int<br>**rotation**: blob rotation, type is float<br>**code**: blob code, type is int<br>**count**: blob count, type is int<br>**perimeter**: blob perimeter, type is int<br>**roundness**: blob roundness, type is float<br>**x_hist_bins**: blob x_hist_bins, type is std::vector<int><br>**y_hist_bins**: blob y_hist_bins, type is std::vector<int><br> **static** False **C++ defination code**: ```cpp Blob(std::vector<int> &rect, std::vector<std::vector<int>> &corners, std::vector<std::vector<int>> &mini_corners,float cx, float cy, int pixels, float rotation, int code, int count, int perimeter, float roundness, std::vector<int> &x_hist_bins, std::vector<int> &y_hist_bins) ``` #### corners item doc **type** func **brief** get blob corners **return** Returns a list of 4 (x,y) tuples of the 4 corners of the object.<br>(x0, y0)___________(x1, y1)<br> <br> <br> <br>___________<br>(x3, y3) (x2, y2)<br>note: the order of corners may change **static** False **C++ defination code**: ```cpp std::vector<std::vector<int>> corners() ``` #### mini\\_corners item doc **type** func **brief** get blob mini corners **return** Returns a list of 4 (x,y) tuples of the 4 corners than bound the min area rectangle of the blob.<br>(x0, y0)___________(x1, y1)<br> <br> <br> <br>___________<br>(x3, y3) (x2, y2)<br>note: the order of corners may change **static** False **C++ defination code**: ```cpp std::vector<std::vector<int>> mini_corners() ``` #### rect item doc **type** func **brief** get blob rect **return** Returns the center coordinates and width and height of the rectangle. format is (x, y, w, h)<br>w<br>(x, y) ___________<br> <br> h<br> <br>___________ **static** False **C++ defination code**: ```cpp std::vector<int> rect() ``` #### x item doc **type** func **brief** get blob x of the upper left coordinate **return** Returns the x coordinate of the upper left corner of the rectangle. **static** False **C++ defination code**: ```cpp int x() ``` #### y item doc **type** func **brief** get blob y of the upper left coordinate **return** Returns the y coordinate of the upper left corner of the rectangle. **static** False **C++ defination code**: ```cpp int y() ``` #### w item doc **type** func **brief** get blob width **return** Returns the blob’s bounding box w coordinate **static** False **C++ defination code**: ```cpp int w() ``` #### h item doc **type** func **brief** get blob height **return** Returns the blob’s bounding box h coordinate **static** False **C++ defination code**: ```cpp int h() ``` #### pixels item doc **type** func **brief** get blob pixels **return** Returns the number of pixels that are part of this blob. **static** False **C++ defination code**: ```cpp int pixels() ``` #### cx item doc **type** func **brief** get blob center x **return** Returns the centroid x position of the blob **static** False **C++ defination code**: ```cpp int cx() ``` #### cy item doc **type** func **brief** get blob center y **return** Returns the centroid y position of the blob **static** False **C++ defination code**: ```cpp int cy() ``` #### cxf item doc **type** func **brief** get blob center x **return** Returns the centroid x position of the blob **static** False **C++ defination code**: ```cpp float cxf() ``` #### cyf item doc **type** func **brief** get blob center y **return** Returns the centroid y position of the blob **static** False **C++ defination code**: ```cpp float cyf() ``` #### rotation item doc **type** func **brief** get blob rotation **return** Returns the rotation of the blob in radians (float). If the blob is like a pencil or pen this value will be unique for 0 180 degrees. **static** False **C++ defination code**: ```cpp float rotation() ``` #### rotation\\_rad item doc **type** func **brief** get blob rotation_rad **return** Returns the rotation of the blob in radians **static** False **C++ defination code**: ```cpp float rotation_rad() ``` #### rotation\\_deg item doc **type** func **brief** get blob rotation_deg **return** Returns the rotation of the blob in degrees. **static** False **C++ defination code**: ```cpp int rotation_deg() ``` #### code item doc **type** func **brief** get blob code **return** Returns a 32 bit binary number with a bit set in it for each color threshold that’s part of this blob **static** False **C++ defination code**: ```cpp int code() ``` #### count item doc **type** func **brief** get blob count **return** Returns the number of blobs merged into this blob. **static** False **C++ defination code**: ```cpp int count() ``` #### perimeter item doc **type** func **brief** get blob merge_cnt **return** Returns the number of pixels on this blob’s perimeter. **static** False **C++ defination code**: ```cpp int perimeter() ``` #### roundness item doc **type** func **brief** get blob roundness **return** Returns a value between 0 and 1 representing how round the object is **static** False **C++ defination code**: ```cpp float roundness() ``` #### elongation item doc **type** func **brief** get blob elongation **returnReturns** a value between 0 and 1 representing how long (not round) the object is **static** False **C++ defination code**: ```cpp float elongation() ``` #### area item doc **type** func **brief** get blob area **return** Returns the area of the bounding box around the blob **static** False **C++ defination code**: ```cpp int area() ``` #### density item doc **type** func **brief** get blob density **return** Returns the density ratio of the blob **static** False **C++ defination code**: ```cpp float density() ``` #### extent item doc **type** func **brief** Alias for blob.density() **return** Returns the density ratio of the blob **static** False **C++ defination code**: ```cpp float extent() ``` #### compactness item doc **type** func **brief** get blob compactness **return** Returns the compactness ratio of the blob **static** False **C++ defination code**: ```cpp float compactness() ``` #### solidity item doc **type** func **brief** get blob solidity **return** Returns the solidity ratio of the blob **static** False **C++ defination code**: ```cpp float solidity() ``` #### convexity item doc **type** func **brief** get blob convexity **return** Returns a value between 0 and 1 representing how convex the object is **static** False **C++ defination code**: ```cpp float convexity() ``` #### x\\_hist\\_bins item doc **type** func **brief** get blob x_hist_bins **return** Returns the x_hist_bins of the blob **static** False **C++ defination code**: ```cpp std::vector<int> x_hist_bins() ``` #### y\\_hist\\_bins item doc **type** func **brief** get blob y_hist_bins **return** Returns the y_hist_bins of the blob **static** False **C++ defination code**: ```cpp std::vector<int> y_hist_bins() ``` #### major\\_axis\\_line item doc **type** func **brief** get blob major_axis_line **return** Returns a line tuple (x1, y1, x2, y2) of the minor axis of the blob. **static** False **C++ defination code**: ```cpp std::vector<int> major_axis_line() ``` #### minor\\_axis\\_line item doc **type** func **brief** get blob minor_axis_line **return** Returns a line tuple (x1, y1, x2, y2) of the minor axis of the blob. **static** False **C++ defination code**: ```cpp std::vector<int> minor_axis_line() ``` #### enclosing\\_circle item doc **type** func **brief** get blob enclosing_circle **return** Returns a circle tuple (x, y, r) of the circle that encloses the min area rectangle of a blob. **static** False **C++ defination code**: ```cpp std::vector<int> enclosing_circle() ``` #### enclosed\\_ellipse item doc **type** func **brief** get blob enclosed_ellipse **return** Returns an ellipse tuple (x, y, rx, ry, rotation) of the ellipse that fits inside of the min area rectangle of a blob. **static** False **C++ defination code**: ```cpp std::vector<int> enclosed_ellipse() ``` ### QRCode item doc **brief** QRCode class **C++ defination code**: ```cpp class QRCode ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** QRCode constructor **param** **rect**: rect of corners, type is std::vector<int><br>**corners**: corners of QRCode<br>**payload**: payload of the QRCode<br>**version**: version of the QRCode<br>**ecc_level**: ecc_level of the QRCode<br>**mask**: mask of the QRCode<br>**data_type**: data_type of the QRCode<br>**eci**: eci of the QRCode<br> **static** False **C++ defination code**: ```cpp QRCode(std::vector<int> &rect, std::vector<std::vector<int>> &corners, std::string &payload, int version, int ecc_level, int mask, int data_type, int eci) ``` #### corners item doc **type** func **brief** get coordinate of QRCode **return** return the coordinate of the QRCode. **static** False **C++ defination code**: ```cpp std::vector<std::vector<int>> corners() ``` #### rect item doc **type** func **brief** get rectangle of QRCode **return** return the rectangle of the QRCode. format is {x, y, w, h}, type is std::vector<int> **static** False **C++ defination code**: ```cpp std::vector<int> rect() ``` #### x item doc **type** func **brief** get x of QRCode **return** return x of the QRCode, type is int **static** False **C++ defination code**: ```cpp int x() ``` #### y item doc **type** func **brief** get y of QRCode **return** return y of the QRCode, type is int **static** False **C++ defination code**: ```cpp int y() ``` #### w item doc **type** func **brief** get w of QRCode **return** return w of the QRCode, type is int **static** False **C++ defination code**: ```cpp int w() ``` #### h item doc **type** func **brief** get h of QRCode **return** return h of the QRCode, type is int **static** False **C++ defination code**: ```cpp int h() ``` #### payload item doc **type** func **brief** get QRCode payload **return** return area of the QRCode **static** False **C++ defination code**: ```cpp std::string payload() ``` #### version item doc **type** func **brief** get QRCode version **return** return version of the QRCode **static** False **C++ defination code**: ```cpp int version() ``` #### ecc\\_level item doc **type** func **brief** get QRCode error correction level **return** return error correction level of the QRCode **static** False **C++ defination code**: ```cpp int ecc_level() ``` #### mask item doc **type** func **brief** get QRCode mask **return** return mask of the QRCode **static** False **C++ defination code**: ```cpp int mask() ``` #### data\\_type item doc **type** func **brief** get QRCode dataType **return** return mask of the QRCode **static** False **C++ defination code**: ```cpp int data_type() ``` #### eci item doc **type** func **brief** get QRCode eci **return** return data of the QRCode **static** False **C++ defination code**: ```cpp int eci() ``` #### is\\_numeric item doc **type** func **brief** check QRCode is numeric **return** return true if the result type of the QRCode is numeric **static** False **C++ defination code**: ```cpp bool is_numeric() ``` #### is\\_alphanumeric item doc **type** func **brief** check QRCode is alphanumeric **return** return true if the result type of the QRCode is alphanumeric **static** False **C++ defination code**: ```cpp bool is_alphanumeric() ``` #### is\\_binary item doc **type** func **brief** check QRCode is binary **return** return true if the result type of the QRCode is binary **static** False **C++ defination code**: ```cpp bool is_binary() ``` #### is\\_kanji item doc **type** func **brief** check QRCode is kanji **return** return true if the result type of the QRCode is kanji **static** False **C++ defination code**: ```cpp bool is_kanji() ``` ### AprilTag item doc **brief** AprilTag class **C++ defination code**: ```cpp class AprilTag ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** AprilTag constructor **param** **rect**: Inlucdes the top left corner and the width and height of the rectangle. format is {x, y, w, h}, type is std::vector<int><br>**corners**: Includes the four corners of the rectangle. format is {{x0, y0}, {x1, y1}, {x2, y2}, {x3, y3}}, type is std::vector<std::vector<int>><br>**id**: The id of the AprilTag<br>**famliy**: The family of the AprilTag<br>**centroid_x**: The x coordinate of the center of the AprilTag<br>**centroid_y**: The y coordinate of the center of the AprilTag<br>**rotation**: The rotation of the AprilTag<br>**decision_margin**: The decision_margin of the AprilTag<br>**hamming**: The hamming of the AprilTag<br>**goodness**: The goodness of the AprilTag<br>**x_translation**: The x_translation of the AprilTag<br>**y_translation**: The y_translation of the AprilTag<br>**z_translation**: The z_translation of the AprilTag<br>**x_rotation**: The x_rotation of the AprilTag<br>**y_rotation**: The y_rotation of the AprilTag<br>**z_rotation**: The z_rotation of the AprilTag<br> **static** False **C++ defination code**: ```cpp AprilTag(std::vector<int> &rect, std::vector<std::vector<int>> &corners, int id, int famliy, float centroid_x, float centroid_y, float rotation, float decision_margin, int hamming, float goodness, float x_translation, float y_translation, float z_translation, float x_rotation, float y_rotation, float z_rotation) ``` #### corners item doc **type** func **brief** get coordinate of AprilTag **return** return the coordinate of the AprilTag. **static** False **C++ defination code**: ```cpp std::vector<std::vector<int>> corners() ``` #### rect item doc **type** func **brief** get rectangle of AprilTag **return** return the rectangle of the AprilTag. format is {x, y, w, h}, type is std::vector<int> **static** False **C++ defination code**: ```cpp std::vector<int> rect() ``` #### x item doc **type** func **brief** get x of AprilTag **return** return x of the AprilTag, type is int **static** False **C++ defination code**: ```cpp int x() ``` #### y item doc **type** func **brief** get y of AprilTag **return** return y of the AprilTag, type is int **static** False **C++ defination code**: ```cpp int y() ``` #### w item doc **type** func **brief** get w of AprilTag **return** return w of the AprilTag, type is int **static** False **C++ defination code**: ```cpp int w() ``` #### h item doc **type** func **brief** get h of AprilTag **return** return h of the AprilTag, type is int **static** False **C++ defination code**: ```cpp int h() ``` #### id item doc **type** func **brief** get id of AprilTag **return** return id of the AprilTag, type is int **static** False **C++ defination code**: ```cpp int id() ``` #### family item doc **type** func **brief** get family of AprilTag **return** return family of the AprilTag, type is int **static** False **C++ defination code**: ```cpp int family() ``` #### cx item doc **type** func **brief** get cx of AprilTag **return** return cx of the AprilTag, type is int **static** False **C++ defination code**: ```cpp int cx() ``` #### cxf item doc **type** func **brief** get cxf of AprilTag **return** return cxf of the AprilTag, type is float **static** False **C++ defination code**: ```cpp float cxf() ``` #### cy item doc **type** func **brief** get cy of AprilTag **return** return cy of the AprilTag, type is int **static** False **C++ defination code**: ```cpp int cy() ``` #### cyf item doc **type** func **brief** get cyf of AprilTag **return** return cyf of the AprilTag, type is float **static** False **C++ defination code**: ```cpp float cyf() ``` #### rotation item doc **type** func **brief** get rotation of AprilTag **return** return rotation of the AprilTag, type is float **static** False **C++ defination code**: ```cpp float rotation() ``` #### decision\\_margin item doc **type** func **brief** Get decision_margin of AprilTag **return** Returns the quality of the apriltag match (0.0 1.0) where 1.0 is the best. **static** False **C++ defination code**: ```cpp float decision_margin() ``` #### hamming item doc **type** func **brief** get hamming of AprilTag **return** Returns the number of accepted bit errors for this tag.<br>return 0, means 0 bit errors will be accepted.<br>1 is TAG25H7, means up to 1 bit error may be accepted<br>2 is TAG25H9, means up to 3 bit errors may be accepted<br>3 is TAG36H10, means up to 3 bit errors may be accepted<br>4 is TAG36H11, means up to 4 bit errors may be accepted<br>5 is ARTOOLKIT, means 0 bit errors will be accepted **static** False **C++ defination code**: ```cpp int hamming() ``` #### goodness item doc **type** func **brief** get goodness of AprilTag **return** return goodness of the AprilTag, type is float<br>Note: This value is always 0.0 for now. **static** False **C++ defination code**: ```cpp float goodness() ``` #### x\\_translation item doc **type** func **brief** get x_translation of AprilTag **return** return x_translation of the AprilTag, type is float **static** False **C++ defination code**: ```cpp float x_translation() ``` #### y\\_translation item doc **type** func **brief** get y_translation of AprilTag **return** return y_translation of the AprilTag, type is float **static** False **C++ defination code**: ```cpp float y_translation() ``` #### z\\_translation item doc **type** func **brief** get z_translation of AprilTag **return** return z_translation of the AprilTag, type is float **static** False **C++ defination code**: ```cpp float z_translation() ``` #### x\\_rotation item doc **type** func **brief** get x_rotation of AprilTag **return** return x_rotation of the AprilTag, type is float **static** False **C++ defination code**: ```cpp float x_rotation() ``` #### y\\_rotation item doc **type** func **brief** get y_rotation of AprilTag **return** return y_rotation of the AprilTag, type is float **static** False **C++ defination code**: ```cpp float y_rotation() ``` #### z\\_rotation item doc **type** func **brief** get z_rotation of AprilTag **return** return z_rotation of the AprilTag, type is float **static** False **C++ defination code**: ```cpp float z_rotation() ``` ### DataMatrix item doc **brief** DataMatrix class **C++ defination code**: ```cpp class DataMatrix ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** DataMatrix constructor **param** **rect**: Inlucdes the top left corner and the width and height of the rectangle. format is {x, y, w, h}, type is std::vector<int><br>**corners**: Includes the four corners of the rectangle. format is {{x0, y0}, {x1, y1}, {x2, y2}, {x3, y3}}, type is std::vector<std::vector<int>><br>**payload**: The payload of the DataMatrix<br>**rotation**: The rotation of the DataMatrix<br>**rows**: The rows of the DataMatrix<br>**columns**: The columns of the DataMatrix<br>**capacity**: The capacity of the DataMatrix<br>**padding**: The padding of the DataMatrix<br> **static** False **C++ defination code**: ```cpp DataMatrix(std::vector<int> &rect, std::vector<std::vector<int>> &corners, std::string &payload, float rotation, int rows, int columns, int capacity, int padding) ``` #### corners item doc **type** func **brief** get coordinate of DataMatrix **return** return the coordinate of the DataMatrix. **static** False **C++ defination code**: ```cpp std::vector<std::vector<int>> corners() ``` #### rect item doc **type** func **brief** get rectangle of DataMatrix **return** return the rectangle of the DataMatrix. format is {x, y, w, h}, type is std::vector<int> **static** False **C++ defination code**: ```cpp std::vector<int> rect() ``` #### x item doc **type** func **brief** get x of DataMatrix **return** return x of the DataMatrix, type is int **static** False **C++ defination code**: ```cpp int x() ``` #### y item doc **type** func **brief** get y of DataMatrix **return** return y of the DataMatrix, type is int **static** False **C++ defination code**: ```cpp int y() ``` #### w item doc **type** func **brief** get w of DataMatrix **return** return w of the DataMatrix, type is int **static** False **C++ defination code**: ```cpp int w() ``` #### h item doc **type** func **brief** get h of DataMatrix **return** return h of the DataMatrix, type is int **static** False **C++ defination code**: ```cpp int h() ``` #### payload item doc **type** func **brief** get payload of DataMatrix **return** return payload of the DataMatrix, type is std::string **static** False **C++ defination code**: ```cpp std::string payload() ``` #### rotation item doc **type** func **brief** get rotation of DataMatrix **return** return rotation of the DataMatrix, type is float **static** False **C++ defination code**: ```cpp float rotation() ``` #### rows item doc **type** func **brief** get rows of DataMatrix **return** return rows of the DataMatrix, type is int **static** False **C++ defination code**: ```cpp int rows() ``` #### columns item doc **type** func **brief** get columns of DataMatrix **return** return columns of the DataMatrix, type is int **static** False **C++ defination code**: ```cpp int columns() ``` #### capacity item doc **type** func **brief** et capacity of DataMatrix **return** returns how many characters could fit in this data matrix, type is int **static** False **C++ defination code**: ```cpp int capacity() ``` #### padding item doc **type** func **brief** get padding of DataMatrix **return** returns how many unused characters are in this data matrix, type is int **static** False **C++ defination code**: ```cpp int padding() ``` ### BarCode item doc **brief** BarCode class **C++ defination code**: ```cpp class BarCode ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** BarCode constructor **param** **rect**: Inlucdes the top left corner and the width and height of the rectangle. format is {x, y, w, h}, type is std::vector<int><br>**corners**: Includes the four corners of the rectangle. format is {{x0, y0}, {x1, y1}, {x2, y2}, {x3, y3}}, type is std::vector<std::vector<int>><br>**payload**: The payload of the BarCode<br>**type**: The type of the BarCode<br>**rotation**: The rotation of the BarCode<br>**quality**: The quality of the BarCode<br> **static** False **C++ defination code**: ```cpp BarCode(std::vector<int> &rect, std::vector<std::vector<int>> &corners, std::string &payload, int type, float rotation, int quality) ``` #### corners item doc **type** func **brief** get coordinate of BarCode **return** return the coordinate of the BarCode. **static** False **C++ defination code**: ```cpp std::vector<std::vector<int>> corners() ``` #### rect item doc **type** func **brief** get rectangle of BarCode **return** return the rectangle of the BarCode. format is {x, y, w, h}, type is std::vector<int> **static** False **C++ defination code**: ```cpp std::vector<int> rect() ``` #### x item doc **type** func **brief** get x of BarCode **return** return x of the BarCode, type is int **static** False **C++ defination code**: ```cpp int x() ``` #### y item doc **type** func **brief** get y of BarCode **return** return y of the BarCode, type is int **static** False **C++ defination code**: ```cpp int y() ``` #### w item doc **type** func **brief** get w of BarCode **return** return w of the BarCode, type is int **static** False **C++ defination code**: ```cpp int w() ``` #### h item doc **type** func **brief** get h of BarCode **return** return h of the BarCode, type is int **static** False **C++ defination code**: ```cpp int h() ``` #### payload item doc **type** func **brief** get payload of BarCode **return** return payload of the BarCode, type is std::string **static** False **C++ defination code**: ```cpp std::string payload() ``` #### type item doc **type** func **brief** get type of BarCode **return** return type of the BarCode, type is int **static** False **C++ defination code**: ```cpp int type() ``` #### rotation item doc **type** func **brief** get rotation of BarCode **return** return rotation of the BarCode, type is float. FIXME: always return 0.0 **static** False **C++ defination code**: ```cpp float rotation() ``` #### quality item doc **type** func **brief** get quality of BarCode **return** return quality of the BarCode, type is int **static** False **C++ defination code**: ```cpp int quality() ``` ### Statistics item doc **brief** Statistics class **C++ defination code**: ```cpp class Statistics ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Statistics constructor **param** **format**: The statistics source image format<br>**l_statistics**: The statistics of the L channel. format is {mean, median, mode, std_dev, min, max, lq, uq}, type is std::vector<int><br>**a_statistics**: The statistics of the A channel. format is {mean, median, mode, std_dev, min, max, lq, uq}, type is std::vector<int><br>**b_statistics**: The statistics of the B channel. format is {mean, median, mode, std_dev, min, max, lq, uq}, type is std::vector<int><br> **static** False **C++ defination code**: ```cpp Statistics(image::Format format, std::vector<int> &l_statistics, std::vector<int> &a_statistics, std::vector<int> &b_statistics) ``` #### format item doc **type** func **brief** get format of Statistics source image **return** return format of the Statistics source image, type is image::Format **static** False **C++ defination code**: ```cpp image::Format format() ``` #### l\\_mean item doc **type** func **brief** get L channel mean **return** return L channel mean, type is int **static** False **C++ defination code**: ```cpp int l_mean() ``` #### l\\_median item doc **type** func **brief** get L channel median **return** return L channel median, type is int **static** False **C++ defination code**: ```cpp int l_median() ``` #### l\\_mode item doc **type** func **brief** get L channel mode **return** return L channel mode, type is int **static** False **C++ defination code**: ```cpp int l_mode() ``` #### l\\_std\\_dev item doc **type** func **brief** get L channel std_dev **return** return L channel std_dev, type is int **static** False **C++ defination code**: ```cpp int l_std_dev() ``` #### l\\_min item doc **type** func **brief** get L channel min **return** return L channel min, type is int **static** False **C++ defination code**: ```cpp int l_min() ``` #### l\\_max item doc **type** func **brief** get L channel max **return** return L channel max, type is int **static** False **C++ defination code**: ```cpp int l_max() ``` #### l\\_lq item doc **type** func **brief** get L channel lq **return** return L channel lq, type is int **static** False **C++ defination code**: ```cpp int l_lq() ``` #### l\\_uq item doc **type** func **brief** get L channel uq **return** return L channel uq, type is int **static** False **C++ defination code**: ```cpp int l_uq() ``` #### a\\_mean item doc **type** func **brief** get A channel mean **return** return A channel mean, type is int **static** False **C++ defination code**: ```cpp int a_mean() ``` #### a\\_median item doc **type** func **brief** get A channea median **return** return A channel median, type is int **static** False **C++ defination code**: ```cpp int a_median() ``` #### a\\_mode item doc **type** func **brief** get A channel mode **return** return A channel mode, type is int **static** False **C++ defination code**: ```cpp int a_mode() ``` #### a\\_std\\_dev item doc **type** func **brief** get A channel std_dev **return** return A channel std_dev, type is int **static** False **C++ defination code**: ```cpp int a_std_dev() ``` #### a\\_min item doc **type** func **brief** get A channel min **return** return A channel min, type is int **static** False **C++ defination code**: ```cpp int a_min() ``` #### a\\_max item doc **type** func **brief** get A channel max **return** return A channel max, type is int **static** False **C++ defination code**: ```cpp int a_max() ``` #### a\\_lq item doc **type** func **brief** get A channel lq **return** return A channel lq, type is int **static** False **C++ defination code**: ```cpp int a_lq() ``` #### a\\_uq item doc **type** func **brief** get A channel uq **return** return A channel uq, type is int **static** False **C++ defination code**: ```cpp int a_uq() ``` #### b\\_mean item doc **type** func **brief** get B channel mean **return** return B channel mean, type is int **static** False **C++ defination code**: ```cpp int b_mean() ``` #### b\\_median item doc **type** func **brief** get B channea median **return** return B channel median, type is int **static** False **C++ defination code**: ```cpp int b_median() ``` #### b\\_mode item doc **type** func **brief** get B channel mode **return** return B channel mode, type is int **static** False **C++ defination code**: ```cpp int b_mode() ``` #### b\\_std\\_dev item doc **type** func **brief** get B channel std_dev **return** return B channel std_dev, type is int **static** False **C++ defination code**: ```cpp int b_std_dev() ``` #### b\\_min item doc **type** func **brief** get B channel min **return** return B channel min, type is int **static** False **C++ defination code**: ```cpp int b_min() ``` #### b\\_max item doc **type** func **brief** get B channel max **return** return B channel max, type is int **static** False **C++ defination code**: ```cpp int b_max() ``` #### b\\_lq item doc **type** func **brief** get B channel lq **return** return B channel lq, type is int **static** False **C++ defination code**: ```cpp int b_lq() ``` #### b\\_uq item doc **type** func **brief** get B channel uq **return** return B channel uq, type is int **static** False **C++ defination code**: ```cpp int b_uq() ``` ### Displacement item doc **brief** Displacement class **C++ defination code**: ```cpp class Displacement ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Displacement constructor **param** **x_translation**: The x_translation of the Displacement<br>**y_translation**: The y_translation of the Displacement<br>**rotation**: The rotation of the Displacement<br>**scale**: The scale of the Displacement<br>**response**: The response of the Displacement<br> **static** False **C++ defination code**: ```cpp Displacement(float x_translation, float y_translation, float rotation, float scale, float response) ``` #### x\\_translation item doc **type** func **brief** get x_translation of Displacement **return** return x_translation of the Displacement, type is float **static** False **C++ defination code**: ```cpp float x_translation() ``` #### y\\_translation item doc **type** func **brief** get y_translation of Displacement **return** return y_translation of the Displacement, type is float **static** False **C++ defination code**: ```cpp float y_translation() ``` #### rotation item doc **type** func **brief** get rotation of Displacement **return** return rotation of the Displacement, type is float **static** False **C++ defination code**: ```cpp float rotation() ``` #### scale item doc **type** func **brief** get scale of Displacement **return** return scale of the Displacement, type is float **static** False **C++ defination code**: ```cpp float scale() ``` #### response item doc **type** func **brief** get response of Displacement **return** return response of the Displacement, type is float **static** False **C++ defination code**: ```cpp float response() ``` ### LBPKeyPoint item doc **brief** LBPKeyPoint class **C++ defination code**: ```cpp class LBPKeyPoint ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** LBPKeyPoint constructor **param** **data**: The data of the LBPKeyPoint<br> **static** False **C++ defination code**: ```cpp LBPKeyPoint(std::valarray<uint8_t> &data) ``` ### KeyPoint item doc **brief** KeyPoint class **C++ defination code**: ```cpp class KeyPoint ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** KeyPoint constructor **param** **x**: The x of the KeyPoint<br>**y**: The y of the KeyPoint<br>**score**: The score of the KeyPoint<br>**octave**: The octave of the KeyPoint<br>**angle**: The angle of the KeyPoint<br>**matched**: The matched of the KeyPoint<br>**desc**: The desc of the KeyPoint<br> **static** False **C++ defination code**: ```cpp KeyPoint(uint16_t x, uint16_t y, uint16_t score, uint16_t octave, uint16_t angle, uint16_t matched, std::vector<uint8_t> &desc) ``` ### KPTMatch item doc **brief** KPTMatch class **C++ defination code**: ```cpp class KPTMatch ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** KPTMatch constructor **param** **cx**: The cx of the KPTMatch<br>**cy**: The cy of the KPTMatch<br>**x**: The x of the KPTMatch<br>**y**: The y of the KPTMatch<br>**w**: The w of the KPTMatch<br>**h**: The h of the KPTMatch<br>**score**: The score of the KPTMatch<br>**theta**: The theta of the KPTMatch<br>**match**: The match of the KPTMatch<br> **static** False **C++ defination code**: ```cpp KPTMatch(int cx, int cy, int x, int y, int w, int h, int score, int theta, int match) ``` ### ORBKeyPoint item doc **brief** ORBKeyPoint class **C++ defination code**: ```cpp class ORBKeyPoint ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** ORBKeyPoint constructor **param** **data**: The data of the ORBKeyPoint<br>**threshold**: The threshold of the ORBKeyPoint<br>**normalized**: The normalized of the ORBKeyPoint<br> **static** False **C++ defination code**: ```cpp ORBKeyPoint(std::vector<image::KeyPoint> &data, int threshold, bool normalized) ``` #### get\\_data item doc **type** func **brief** get data of ORBKeyPoint **return** return data of the ORBKeyPoint, type is std::vector<KeyPoint> **static** False **C++ defination code**: ```cpp std::vector<image::KeyPoint> get_data() ``` ### HaarCascade item doc **brief** HaarCascade class **C++ defination code**: ```cpp class HaarCascade ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** HaarCascade constructor **param** **data**: The data of the HaarCascade<br>**threshold**: The threshold of the HaarCascade<br>**normalized**: The normalized of the HaarCascade<br> **static** False **C++ defination code**: ```cpp HaarCascade() ``` ### Color item doc **brief** Color class **C++ defination code**: ```cpp class Color ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Color constructor **param** **alpha**: alpha channel, value range: 0 ~ 1<br> **static** False **C++ defination code**: ```cpp Color(uint8_t ch1, uint8_t ch2 0, uint8_t ch3 0, float alpha 0, image::Format format image::FMT_GRAYSCALE) ``` #### r item doc **type** var **brief** Color red channel **static** False **readonly** False **C++ defination code**: ```cpp uint8_t r ``` #### g item doc **type** var **brief** Color green channel **static** False **readonly** False **C++ defination code**: ```cpp uint8_t g ``` #### b item doc **type** var **brief** Color blue channel **static** False **readonly** False **C++ defination code**: ```cpp uint8_t b ``` #### alpha item doc **type** var **brief** Color alpha channel, value from 0.0 to 1.0, float value **static** False **readonly** False **C++ defination code**: ```cpp float alpha ``` #### gray item doc **type** var **brief** Color gray channel **static** False **readonly** False **C++ defination code**: ```cpp uint8_t gray ``` #### format item doc **type** var **brief** Color format **static** False **readonly** False **C++ defination code**: ```cpp image::Format format ``` #### hex item doc **type** func **brief** Get color's hex value **static** False **C++ defination code**: ```cpp uint32_t hex() ``` #### from\\_rgb item doc **type** func **brief** Create Color object from RGB channels **static** True **C++ defination code**: ```cpp static image::Color from_rgb(uint8_t r, uint8_t g, uint8_t b) ``` #### from\\_bgr item doc **type** func **brief** Create Color object from BGR channels **static** True **C++ defination code**: ```cpp static image::Color from_bgr(uint8_t b, uint8_t g, uint8_t r) ``` #### from\\_gray item doc **type** func **brief** Create Color object from gray channel **static** True **C++ defination code**: ```cpp static image::Color from_gray(uint8_t gray) ``` #### from\\_rgba item doc **type** func **brief** Create Color object from RGBA channels **param** **alpha**: alpha channel, float value, value range: 0 ~ 1<br> **static** True **C++ defination code**: ```cpp static image::Color from_rgba(uint8_t r, uint8_t g, uint8_t b, float alpha) ``` #### from\\_bgra item doc **type** func **brief** Create Color object from BGRA channels **param** **alpha**: alpha channel, float value, value range: 0 ~ 1<br> **static** True **C++ defination code**: ```cpp static image::Color from_bgra(uint8_t b, uint8_t g, uint8_t r, float alpha) ``` #### from\\_hex item doc **type** func **brief** Create Color object from hex value **param** **hex**: hex value, e.g. 0x0000FF00, lower address if first channel<br>**format**: color format, @see image::Format<br> **static** True **C++ defination code**: ```cpp static image::Color from_hex(uint32_t hex, image::Format &format) ``` #### to\\_format item doc **type** func **brief** Convert Color format **param** **format**: format want to convert to, @see image::Format, only support RGB888, BGR888, RGBA8888, BGRA8888, GRAYSCALE.<br> **static** False **C++ defination code**: ```cpp void to_format(const image::Format &format) ``` #### to\\_format2 item doc **type** func **brief** Convert color format and return a new Color object **param** **format**: format want to convert to, @see image::Format, only support RGB888, BGR888, RGBA8888, BGRA8888, GRAYSCALE.<br> **return** new Color object, you need to delete it manually in C++. **static** False **C++ defination code**: ```cpp image::Color *to_format2(const image::Format &format) ``` ### Image item doc **brief** Image class **C++ defination code**: ```cpp class Image ``` #### \\_\\_init\\_\\_ item doc **type** func **brief** Image constructor **param** **width**: image width, should > 0<br>**height**: image height, should > 0<br>**format**: image format @see image::Format<br>**data**: image data, if data is nullptr, will malloc memory for image data<br>If the image is in jpeg format, data must be filled in.<br>**data_size**: image data size, only for compressed format like jpeg png, data_size must be filled in.<br>**copy**: if true and data is not nullptr, will copy data to new buffer, else will use data directly. default is true to avoid memory leak.<br> **static** False **C++ defination code**: ```cpp Image(int width, int height, image::Format format image::Format::FMT_RGB888, void *data nullptr, int data_size 1, bool copy true) ``` #### format item doc **type** func **brief** Get image's format **see** image.Format **static** False **C++ defination code**: ```cpp image::Format format() ``` #### size item doc **type** func **brief** Get image's size, [width, height] **static** False **C++ defination code**: ```cpp image::Size size() ``` #### data\\_size item doc **type** func **brief** Get image's data size **static** False **C++ defination code**: ```cpp int data_size() ``` #### width item doc **type** func **brief** Get image's width **static** False **C++ defination code**: ```cpp int width() ``` #### height item doc **type** func **brief** Get image's height **static** False **C++ defination code**: ```cpp int height() ``` #### data item doc **type** func **brief** Get image's data pointer.\\nIn MaixPy is capsule object. **static** False **C++ defination code**: ```cpp void *data() ``` #### \\_\\_str\\_\\_ item doc **type** func **brief** To string method **static** False **C++ defination code**: ```cpp std::string __str__() ``` #### to\\_str item doc **type** func **brief** To string method **static** False **C++ defination code**: ```cpp std::string to_str() ``` #### get\\_pixel item doc **type** func **brief** Get pixel of image **param** **x**: pixel's coordinate x. x must less than image's width<br>**y**: pixel's coordinate y. y must less than image's height<br>**rgbtuple**: switch return value method. rgbtuple decides whether to split the return or not. default is false.<br> **return** pixel value,<br>According to image format and rgbtuple, return different value:<br>format is FMT_RGB888, rgbtuple is true, return [R, G, B]; rgbtuple is false, return [RGB]<br>foramt is FMT_BGR888, rgbtuple is true, return [B, G, R]; rgbtuple is false, return [BGR]<br>format is FMT_GRAYSCALE, return [GRAY]; **static** False **C++ defination code**: ```cpp std::vector<int> get_pixel(int x, int y, bool rgbtuple false) ``` #### set\\_pixel item doc **type** func **brief** Set pixel of image **param** **x**: pixel's coordinate x. x must less than image's width<br>**y**: pixel's coordinate y. y must less than image's height<br>**pixel**: pixel value, according to image format and size of pixel, has different operation:<br>format is FMT_RGB888, pixel size must be 1 or 3, if size is 1, will split pixel[0] to [R, G, B]; if size is 3, will use pixel directly<br>format is FMT_BGR888, pixel size must be 1 or 3, if size is 1, will split pixel[0] to [B, G, R]; if size is 3, will use pixel directly<br>format is FMT_GRAYSCALE, pixel size must be 1, will use pixel directly<br> **return** error code, Err::ERR_NONE is ok, other is error **static** False **C++ defination code**: ```cpp err::Err set_pixel(int x, int y, std::vector<int> pixel) ``` #### to\\_tensor item doc **type** func **brief** Convert Image object to tensor::Tensor object **param** **chw**: if true, the shape of tensor is [C, H, W], else [H, W, C]<br>**copy**: if true, will alloc memory for tensor data, else will use the memory of Image object<br> **return** tensor::Tensor object pointer, an allocated tensor object **static** False **C++ defination code**: ```cpp tensor::Tensor *to_tensor(bool chw false, bool copy true) ``` #### to\\_bytes item doc **type** func **brief** Get image's data and convert to array bytes **param** **copy**: if true, will alloc memory and copy data to new buffer,<br>else will use the memory of Image object, delete bytes object will not affect Image object，<br>but delete Image object will make bytes object invalid, it may cause program crash !!!!<br>So use this param carefully.<br> **return** image's data bytes, need be delete by caller in C++. **static** False **C++ defination code**: ```cpp Bytes *to_bytes(bool copy true) ``` #### to\\_format item doc **type** func **brief** Convert image to specific format **param** **format**: format want to convert to, @see image::Format, only support RGB888, BGR888, RGBA8888, BGRA8888, GRAYSCALE, JPEG.<br> **return** new image object. Need be delete by caller in C++. **throw** err.Exception, if two images' format not support, **or already the format**, will raise exception **static** False **C++ defination code**: ```cpp image::Image *to_format(const image::Format &format) ``` #### draw\\_image item doc **type** func **brief** Draw image on this image **param** **x**: left top corner of image point's coordinate x<br>**y**: left top corner of image point's coordinate y<br>**img**: image object to draw, the caller's channel must < the args' channel,<br>e.g. caller is RGB888, args is RGBA8888, will throw exception, but caller is RGBA8888, args is RGB888 or RGBA8888 is ok<br> **return** this image object self **static** False **C++ defination code**: ```cpp image::Image *draw_image(int x, int y, image::Image &img) ``` #### draw\\_rect item doc **type** func **brief** Fill rectangle color to image **param** **x**: left top corner of rectangle point's coordinate x<br>**y**: left top corner of rectangle point's coordinate y<br>**w**: rectangle width<br>**h**: rectangle height<br>**color**: rectangle color<br>**thickness**: rectangle thickness(line width), by default(value is 1), 1 means fill rectangle<br> **return** this image object self **static** False **C++ defination code**: ```cpp image::Image *draw_rect(int x, int y, int w, int h, const image::Color &color, int thickness 1) ``` #### draw\\_line item doc **type** func **brief** Draw line on image **param** **x1**: start point's coordinate x<br>**y1**: start point's coordinate y<br>**x2**: end point's coordinate x<br>**y2**: end point's coordinate y<br>**color**: line color @see image::Color<br>**thickness**: line thickness(line width), by default(value is 1)<br> **return** this image object self **static** False **C++ defination code**: ```cpp image::Image *draw_line(int x1, int y1, int x2, int y2, const image::Color &color, int thickness 1) ``` #### draw\\_circle item doc **type** func **brief** Draw circle on image **param** **x**: circle center point's coordinate x<br>**y**: circle center point's coordinate y<br>**radius**: circle radius<br>**color**: circle color @see image::Color<br>**thickness**: circle thickness(line width), by default(value is 1), 1 means fill circle<br> **return** this image object self **static** False **C++ defination code**: ```cpp image::Image *draw_circle(int x, int y, int radius, const image::Color &color, int thickness 1) ``` #### draw\\_ellipse item doc **type** func **brief** Draw ellipse on image **param** **x**: ellipse center point's coordinate x<br>**y**: ellipse center point's coordinate y<br>**a**: ellipse major axis length<br>**b**: ellipse minor axis length<br>**angle**: ellipse rotation angle<br>**start_angle**: ellipse start angle<br>**end_angle**: ellipse end angle<br>**color**: ellipse color @see image::Color<br>**thickness**: ellipse thickness(line width), by default(value is 1), 1 means fill ellipse<br> **return** this image object self **static** False **C++ defination code**: ```cpp image::Image *draw_ellipse(int x, int y, int a, int b, float angle, float start_angle, float end_angle, const image::Color &color, int thickness 1) ``` #### draw\\_text item doc **type** func **brief** Draw text on image **param** **x**: text left top point's coordinate x<br>**y**: text left top point's coordinate y<br>**text**: text content<br>**color**: text color @see image::Color, default is white<br>**scale**: font scale, by default(value is 1)<br>**thickness**: text thickness(line width), if negative, the glyph is filled, by default(value is 1)<br>**wrap**: if true, will auto wrap text to next line if text width > image width, by default(value is true)<br> **return** this image object self **static** False **C++ defination code**: ```cpp image::Image *draw_text(int x, int y, const std::string &text, const image::Color &color image::COLOR_WHITE, float scale 1, int thickness 1, bool wrap true, int wrap_space 4, const std::string &font \"\") ``` #### draw\\_arrow item doc **type** func **brief** Draw arrow on image **param** **x0**: start coordinate of the arrow x0<br>**y0**: start coordinate of the arrow y0<br>**x1**: end coordinate of the arrow x1<br>**y1**: end coordinate of the arrow y1<br>**color**: cross color @see image::Color<br>**thickness**: cross thickness(line width), by default(value is 1)<br> **return** this image object self **static** False **C++ defination code**: ```cpp image::Image *draw_arrow(int x0, int y0, int x1, int y1, const image::Color &color, int thickness 1) ``` #### draw\\_edges item doc **type** func **brief** Draw edges on image **param** **corners**: edges, [[x0, y0], [x1, y1], [x2, y2], [x3, y3]]<br>**color**: edges color @see image::Color<br>**size**: the circle of radius size. TODO: support in the feature<br>**thickness**: edges thickness(line width), by default(value is 1)<br>**fill**: if true, will fill edges, by default(value is false)<br> **return** this image object self **static** False **C++ defination code**: ```cpp image::Image *draw_edges(std::vector<std::vector<int>> corners, const image::Color &color, int size 0, int thickness 1, bool fill false) ``` #### draw\\_keypoints item doc **type** func **brief** Draw keypoints on image **param** **keypoints**: keypoints, [x, y, rotation_andle_in_degrees], TODO: rotation_andle_in_degrees support in the feature<br>**color**: keypoints color @see image::Color<br>**size**: size of keypoints<br>**thickness**: keypoints thickness(line width), by default(value is 1)<br>**fill**: if true, will fill keypoints, by default(value is false)<br> **return** this image object self **static** False **C++ defination code**: ```cpp image::Image *draw_keypoints(std::vector<int> keypoints, const image::Color &color, int size 10, int thickness 1, bool fill false) ``` #### resize item doc **type** func **brief** Resize image, will create a new resized image object **param** **width**: new width, if value is 1, will use height to calculate aspect ratio<br>**height**: new height, if value is 1, will use width to calculate aspect ratio<br>**object_fit**: fill, contain, cover, by default is fill<br>**method**: resize method, by default is bilinear<br> **return** Always return a new resized image object even size not change, So in C++ you should take care of the return value to avoid memory leak.<br>And it's better to judge whether the size has changed before calling this function to make the program more efficient.<br>e.g.<br>if img >width() ! width img >height() ! height:<br>img img >resize(width, height); **static** False **C++ defination code**: ```cpp image::Image *resize(int width, int height, image::Fit object_fit image::Fit::FIT_FILL, image::ResizeMethod method image::ResizeMethod::NEAREST) ``` #### affine item doc **type** func **brief** Affine transform image, will create a new transformed image object **param** **src_points**: three source points, [x1, y1, x2, y2, x3, y3]<br>**dst_points**: three destination points, [x1, y1, x2, y2, x3, y3]<br>**width**: new width, if value is 1, will use height to calculate aspect ratio<br>**height**: new height, if value is 1, will use width to calculate aspect ratio<br>**method**: resize method, by default is bilinear<br> **return** new transformed image object **static** False **C++ defination code**: ```cpp image::Image *affine(std::vector<int> src_points, std::vector<int> dst_points, int width 1, int height 1, image::ResizeMethod method image::ResizeMethod::BILINEAR) ``` #### copy item doc **type** func **brief** Copy image, will create a new copied image object **return** new copied image object **static** False **C++ defination code**: ```cpp image::Image *copy() ``` #### crop item doc **type** func **brief** Crop image, will create a new cropped image object **param** **x**: left top corner of crop rectangle point's coordinate x<br>**y**: left top corner of crop rectangle point's coordinate y<br>**w**: crop rectangle width<br>**h**: crop rectangle height<br> **return** new cropped image object **static** False **C++ defination code**: ```cpp image::Image *crop(int x, int y, int w, int h) ``` #### rotate item doc **type** func **brief** Rotate image, will create a new rotated image object **param** **angle**: anti clock wise rotate angle, if angle is 90 or 270, and width or height is 1, will swap width and height, or will throw exception<br>**width**: new width, if value is 1, will use height to calculate aspect ratio<br>**height**: new height, if value is 1, will use width to calculate aspect ratio<br>**method**: resize method, by default is bilinear<br> **return** new rotated image object **static** False **C++ defination code**: ```cpp image::Image *rotate(float angle, int width 1, int height 1, image::ResizeMethod method image::ResizeMethod::BILINEAR) ``` #### mean\\_pool item doc **type** func **brief** Finds the mean of x_div * y_div squares in the image and returns the modified image composed of the mean of each square. **param** **x_div**: The width of the squares.<br>**y_div**: The height of the squares.<br>**copy**: Select whether to return a new image or modify the original image. default is false.<br>If true, returns a new image composed of the mean of each square; If false, returns the modified image composed of the mean of each square.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *mean_pool(int x_div, int y_div, bool copy false) ``` #### midpoint\\_pool item doc **type** func **brief** Finds the midpoint of x_div * y_div squares in the image and returns the modified image composed of the mean of each square. **param** **x_div**: The width of the squares.<br>**y_div**: The height of the squares.<br>**bias**: The bias of the midpoint. default is 0.5.<br>midpoint value is equal to (max * bias + min * (1 bias))<br>**copy**: Select whether to return a new image or modify the original image. default is false.<br>If true, returns a new image composed of the midpoint of each square; If false, returns the modified image composed of the midpoint of each square.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *midpoint_pool(int x_div, int y_div, double bias 0.5, bool copy false) ``` #### compress item doc **type** func **brief** JPEG compresses the image in place. **param** **quality**: The quality of the compressed image. default is 95.<br> **return** Returns the compressed JPEG image **static** False **C++ defination code**: ```cpp image::Image *compress(int quality 95) ``` #### clear item doc **type** func **brief** Sets all pixels in the image to zero **param** **mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *clear(image::Image *mask nullptr) ``` #### mask\\_rectange item doc **type** func **brief** Zeros a rectangular part of the image. If no arguments are supplied this method zeros the center of the image. **param** **x**: The x coordinate of the top left corner of the rectangle.<br>**y**: The y coordinate of the top left corner of the rectangle.<br>**w**: The width of the rectangle.<br>**h**: The height of the rectangle.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *mask_rectange(int x 1, int y 1, int w 1, int h 1) ``` #### mask\\_circle item doc **type** func **brief** Zeros a circular part of the image. If no arguments are supplied this method zeros the center of the image. **param** **x**: The x coordinate of the center of the circle.<br>**y**: The y coordinate of the center of the circle.<br>**radius**: The radius of the circle.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *mask_circle(int x 1, int y 1, int radius 1) ``` #### mask\\_ellipse item doc **type** func **brief** Zeros a ellipse part of the image. If no arguments are supplied this method zeros the center of the image. **param** **x**: The x coordinate of the center of the ellipse.<br>**y**: The y coordinate of the center of the ellipse.<br>**radius_x**: The radius of the ellipse in the x direction.<br>**radius_y**: The radius of the ellipse in the y direction.<br>**rotation_angle_in_degrees**: The rotation angle of the ellipse in degrees.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *mask_ellipse(int x 1, int y 1, int radius_x 1, int radius_y 1, float rotation_angle_in_degrees 0) ``` #### binary item doc **type** func **brief** Sets all pixels in the image to black or white depending on if the pixel is inside of a threshold in the threshold list thresholds or not. **param** **thresholds**: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br>**invert**: If true, the thresholds will be inverted before the operation. default is false.<br>**zero**: If zero is true, the image will be set the pixels within the threshold to 0, other pixels remain unchanged. If zero is false, the image will be set to black or white. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br>**to_bitmap**: If true, the image will be converted to a bitmap image before thresholding. default is false. TODO: support in the feature<br>**copy**: Select whether to return a new image or modify the original image. default is false.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *binary(std::vector<std::vector<int>> thresholds std::vector<std::vector<int>>(), bool invert false, bool zero false, image::Image *mask nullptr, bool to_bitmap false, bool copy false) ``` #### invert item doc **type** func **brief** Inverts the image in place. **return** Returns the image after the operation is completed **static** False **C++ defination code**: ```cpp image::Image *invert() ``` #### b\\_and item doc **type** func **brief** Performs a bitwise and operation between the image and the other image. **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *b_and(image::Image *other, image::Image *mask nullptr) ``` #### b\\_nand item doc **type** func **brief** Performs a bitwise nand operation between the image and the other image. **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *b_nand(image::Image *other, image::Image *mask nullptr) ``` #### b\\_or item doc **type** func **brief** Performs a bitwise or operation between the image and the other image. **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *b_or(image::Image *other, image::Image *mask nullptr) ``` #### b\\_nor item doc **type** func **brief** Performs a bitwise nor operation between the image and the other image. **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *b_nor(image::Image *other, image::Image *mask nullptr) ``` #### b\\_xor item doc **type** func **brief** Performs a bitwise xor operation between the image and the other image. **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *b_xor(image::Image *other, image::Image *mask nullptr) ``` #### b\\_xnor item doc **type** func **brief** Performs a bitwise xnor operation between the image and the other image. **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *b_xnor(image::Image *other, image::Image *mask nullptr) ``` #### awb item doc **type** func **brief** Performs an auto white balance operation on the image. TODO: support in the feature **param** **max**: if True uses the white patch algorithm instead. default is false.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *awb(bool max false) ``` #### ccm item doc **type** func **brief** Multiples the passed (3x3) or (4x3) floating point color correction matrix with the image.\\nnote: Grayscale format is not support. **param** **matrix**: The color correction matrix to use. 3x3 or 4x3 matrix.<br>Weights may either be positive or negative, and the sum of each column in the 3x3 matrix should generally be 1.<br>example:<br>{<br>1, 0, 0,<br>0, 1, 0,<br>0, 0, 1,<br>}<br>Where the last row of the 4x3 matrix is an offset per color channel. If you add an offset you may wish to make the<br>weights sum to less than 1 to account for the offset.<br>example:<br>{<br>1, 0, 0,<br>0, 1, 0,<br>0, 0, 1,<br>0, 0, 0,<br>}<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *ccm(std::vector<float> &matrix) ``` #### gamma item doc **type** func **brief** Quickly changes the image gamma, contrast, and brightness. Create a array whose size is usually 255,\\nand use the parameters gamma, contrast, and brightness to calculate the value of the array, and then map the\\nimage pixel value through the value of the array.\\nThe calculation method for array is: array[array_idx] (powf((array_idx / 255.0), (1 / gamma)) * contrast + brightness) * scale,\\n`powf` is a function used to calculate floating point power.\\n`array` is the array used for mapping.\\n`array_idx` is the index of the array, the maximum value is determined according to the image format, usually 255.\\n`scale` is a constant, the value is determined by the image format, usually 255.\\nMapping method:\\nAssume that a pixel value in the image is 128, then map the pixel value to the value of array[128]\\nUsers can adjust the value of the array through the gamma, contrast, and brightness parameters. **param** **gamma**: The contrast gamma greater than 1.0 makes the image darker in a non linear manner while less than 1.0 makes the image brighter. default is 1.0.<br>**contrast**: The contrast value greater than 1.0 makes the image brighter in a linear manner while less than 1.0 makes the image darker. default is 1.0.<br>**brightness**: The brightness value greater than 0.0 makes the image brighter in a constant manner while less than 0.0 makes the image darker. default is 0.0.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *gamma(double gamma 1.0, double contrast 1.0, double brightness 0.0) ``` #### gamma\\_corr item doc **type** func **brief** Alias for Image.gamma. **param** **gamma**: The contrast gamma greater than 1.0 makes the image darker in a non linear manner while less than 1.0 makes the image brighter. default is 1.0.<br>**contrast**: The contrast value greater than 1.0 makes the image brighter in a linear manner while less than 1.0 makes the image darker. default is 1.0.<br>**brightness**: The brightness value greater than 0.0 makes the image brighter in a constant manner while less than 0.0 makes the image darker. default is 0.0.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *gamma_corr(double gamma, double contrast 1.0, double brightness 0.0) ``` #### negate item doc **type** func **brief** Flips (numerically inverts) all pixels values in an image **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *negate() ``` #### replace item doc **type** func **brief** Replaces all pixels in the image with the corresponding pixels in the other image. **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**hmirror**: If true, the image will be horizontally mirrored before the operation. default is false.<br>**vflip**: If true, the image will be vertically flipped before the operation. default is false.<br>**transpose**: If true, the image can be used to rotate 90 degrees or 270 degrees.<br>hmirror false, vflip false, transpose false, the image will not be rotated.<br>hmirror false, vflip true, transpose true, the image will be rotated 90 degrees.<br>hmirror true, vflip true, transpose false, the image will be rotated 180 degrees.<br>hmirror true, vflip false, transpose true, the image will be rotated 270 degrees.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *replace(image::Image *other nullptr, bool hmirror false, bool vflip false, bool transpose false, image::Image *mask nullptr) ``` #### set item doc **type** func **brief** Alias for Image::replace. **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**hmirror**: If true, the image will be horizontally mirrored before the operation. default is false.<br>**vflip**: If true, the image will be vertically flipped before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *set(image::Image *other, bool hmirror false, bool vflip false, bool transpose false, image::Image *mask nullptr) ``` #### add item doc **type** func **brief** Adds the other image to the image. **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *add(image::Image *other, image::Image *mask nullptr) ``` #### sub item doc **type** func **brief** Subtracts the other image from the image. **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**reverse**: If true, the image will be reversed before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *sub(image::Image *other, bool reverse false, image::Image *mask nullptr) ``` #### mul item doc **type** func **brief** Multiplies the image by the other image.\\nNote: This method is meant for image blending and cannot multiply the pixels in the image by a scalar like 2. **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**invert**: If true, the image will be change the multiplication operation from a*b to 1/((1/a)*(1/b)).<br>In particular, this lightens the image instead of darkening it (e.g. multiply versus burn operations). default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *mul(image::Image *other, bool invert false, image::Image *mask nullptr) ``` #### div item doc **type** func **brief** Divides the image by the other image.\\nThis method is meant for image blending and cannot divide the pixels in the image by a scalar like 2. **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**invert**: If true, the image will be change the division direction from a/b to b/a. default is false.<br>**mod**: If true, the image will be change the division operation to the modulus operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *div(image::Image *other, bool invert false, bool mod false, image::Image *mask nullptr) ``` #### min item doc **type** func **brief** Caculate the minimum of each pixel in the image and the other image. **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *min(image::Image *other, image::Image *mask nullptr) ``` #### max item doc **type** func **brief** Caculate the maximum of each pixel in the image and the other image. **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *max(image::Image *other, image::Image *mask nullptr) ``` #### difference item doc **type** func **brief** Caculate the absolute value of the difference between each pixel in the image and the other image. **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *difference(image::Image *other, image::Image *mask nullptr) ``` #### blend item doc **type** func **brief** Blends the image with the other image.\\nres alpha * this_img / 256 + (256 alpha) * other_img / 256 **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**alpha**: The alpha value of the blend, the value range is [0, 256],default is 128.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *blend(image::Image *other, int alpha 128, image::Image *mask nullptr) ``` #### histeq item doc **type** func **brief** Runs the histogram equalization algorithm on the image. **param** **adaptive**: If true, an adaptive histogram equalization method will be run on the image instead which as generally better results than non adaptive histogram qualization but a longer run time. default is false.<br>**clip_limit**: Provides a way to limit the contrast of the adaptive histogram qualization. Use a small value for this, like 10, to produce good histogram equalized contrast limited images. default is 1.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *histeq(bool adaptive false, int clip_limit 1, image::Image *mask nullptr) ``` #### mean item doc **type** func **brief** Standard mean blurring filter using a box filter.\\nThe parameters offset and invert are valid when threshold is True. **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *mean(int size, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) ``` #### median item doc **type** func **brief** Runs the median filter on the image. The median filter is the best filter for smoothing surfaces while preserving edges but it is very slow. **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**percentile**: This parameter controls the percentile of the value used in the kernel. You can set this to 0 for a min filter, 0.25 for a lower quartile filter, 0.75 for an upper quartile filter, and 1.0 for a max filter. default is 0.5.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *median(int size, double percentile 0.5, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) ``` #### mode item doc **type** func **brief** Runs the mode filter on the image by replacing each pixel with the mode of their neighbors. **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *mode(int size, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) ``` #### midpoint item doc **type** func **brief** Runs the midpoint filter on the image.This filter finds the midpoint (max * bias + min * (1 bias)) of each pixel neighborhood in the image. **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**bias**: The bias of the midpoint. default is 0.5.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *midpoint(int size, double bias 0.5, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) ``` #### morph item doc **type** func **brief** Convolves the image by a filter kernel. This allows you to do general purpose convolutions on an image. **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**kernel**: The kernel used for convolution. The kernel should be a list of lists of numbers. The kernel should be the same size as the actual kernel size.<br>**mul**: This parameter is used to multiply the convolved pixel results. default is auto.<br>**add**: This parameter is the value to be added to each convolution pixel result. default is 0.0.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *morph(int size, std::vector<int> kernel, float mul 1, float add 0.0, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) ``` #### gaussian item doc **type** func **brief** Convolves the image by a smoothing guassian kernel. **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**unsharp**: If true, this method will perform an unsharp mask operation instead of gaussian filtering operation, this improves the clarity of image edges. default is false.<br>**mul**: This parameter is used to multiply the convolved pixel results. default is auto.<br>**add**: This parameter is the value to be added to each convolution pixel result. default is 0.0.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *gaussian(int size, bool unsharp false, float mul 1, float add 0.0, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) ``` #### laplacian item doc **type** func **brief** Convolves the image by a edge detecting laplacian kernel. **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**sharpen**: If True, this method will sharpen the image instead of an unthresholded edge detection image. Then increase the kernel size to improve image clarity. default is false.<br>**mul**: This parameter is used to multiply the convolved pixel results. default is auto.<br>**add**: This parameter is the value to be added to each convolution pixel result. default is 0.0.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *laplacian(int size, bool sharpen false, float mul 1, float add 0.0, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) ``` #### bilateral item doc **type** func **brief** Convolves the image by a bilateral filter. **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**color_sigma**: Controls how closely colors are matched using the bilateral filter. default is 0.1.<br>**space_sigma**: Controls how closely pixels space wise are blurred with each other. default is 1.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *bilateral(int size, double color_sigma 0.1, double space_sigma 1, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) ``` #### linpolar item doc **type** func **brief** Re project’s and image from cartessian coordinates to linear polar coordinates. **param** **reverse**: If true, the image will be reverse polar transformed. default is false.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *linpolar(bool reverse false) ``` #### logpolar item doc **type** func **brief** Re project’s and image from cartessian coordinates to log polar coordinates. **param** **reverse**: If true, the image will be reverse polar transformed. default is false.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *logpolar(bool reverse false) ``` #### lens\\_corr item doc **type** func **brief** Performs a lens correction operation on the image. TODO: support in the feature **param** **strength**: The strength of the lens correction. default is 1.8.<br>**zoom**: The zoom of the lens correction. default is 1.0.<br>**x_corr**: The x correction of the lens correction. default is 0.5.<br>**y_corr**: The y correction of the lens correction. default is 0.5.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *lens_corr(double strength 1.8, double zoom 1.0, double x_corr 0.5, double y_corr 0.5) ``` #### rotation\\_corr item doc **type** func **brief** Performs a rotation correction operation on the image. TODO: support in the feature **param** **x_rotation**: The x rotation of the rotation correction. default is 0.0.<br>**y_rotation**: The y rotation of the rotation correction. default is 0.0.<br>**z_rotation**: The z rotation of the rotation correction. default is 0.0.<br>**x_translation**: The x translation of the rotation correction. default is 0.0.<br>**y_translation**: The y translation of the rotation correction. default is 0.0.<br>**zoom**: The zoom of the rotation correction. default is 1.0.<br>**fov**: The fov of the rotation correction. default is 60.0.<br>**corners**: The corners of the rotation correction. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *rotation_corr(double x_rotation 0.0, double y_rotation 0.0, double z_rotation 0.0, double x_translation 0.0, double y_translation 0.0, double zoom 1.0, double fov 60.0, std::vector<float> corners std::vector<float>()) ``` #### get\\_histogram item doc **type** func **brief** Gets the histogram of the image. **param** **thresholds**: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br>**invert**: If true, the thresholds will be inverted before the operation. default is false.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**bins**: The number of bins to use for the histogram.<br>In GRAYSCALE format, setting range is [2, 256], default is 100.<br>In rgb888 format, setting range is [2, 100], default is 100.<br>**l_bins**: The number of bins to use for the l channel of the histogram. Only valid in RGB888 format.<br>If an invalid value is set, bins will be used instead. The setting range is [2, 100], default is 100.<br>**a_bins**: The number of bins to use for the a channel of the histogram.<br>Only valid in RGB888 format.The setting range is [2, 256], default is 256.<br>**b_bins**: The number of bins to use for the b channel of the histogram.<br>Only valid in RGB888 format. The setting range is [2, 256], default is 256.<br>**difference**: difference may be set to an image object to cause this method to operate on the difference image between the current image and the difference image object.<br>default is None.<br> **return** Returns the histogram of the image **static** False **C++ defination code**: ```cpp std::map<std::string, std::vector<float>> get_histogram(std::vector<std::vector<int>> thresholds std::vector<std::vector<int>>(), bool invert false, std::vector<int> roi std::vector<int>(), int bins 1, int l_bins 100, int a_bins 256, int b_bins 256, image::Image *difference nullptr) ``` #### get\\_statistics item doc **type** func **brief** Gets the statistics of the image. TODO: support in the feature **param** **thresholds**: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**bins**: The number of bins to use for the statistics. default is 1.<br>**l_bins**: The number of bins to use for the l channel of the statistics. default is 1.<br>**a_bins**: The number of bins to use for the a channel of the statistics. default is 1.<br>**b_bins**: The number of bins to use for the b channel of the statistics. default is 1.<br>**difference**: The difference image to use for the statistics. default is None.<br> **return** Returns the statistics of the image **static** False **C++ defination code**: ```cpp image::Statistics get_statistics(std::vector<std::vector<int>> thresholds std::vector<std::vector<int>>(), bool invert false, std::vector<int> roi std::vector<int>(), int bins 1, int l_bins 1, int a_bins 1, int b_bins 1, image::Image *difference nullptr) ``` #### get\\_regression item doc **type** func **brief** Gets the regression of the image. **param** **thresholds**: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**x_stride**: The x stride to use for the regression. default is 2.<br>**y_stride**: The y stride to use for the regression. default is 1.<br>**area_threshold**: The area threshold to use for the regression. default is 10.<br>**pixels_threshold**: The pixels threshold to use for the regression. default is 10.<br>**robust**: If true, the regression will be robust. default is false.<br> **return** Returns the regression of the image **static** False **C++ defination code**: ```cpp std::vector<image::Line> get_regression(std::vector<std::vector<int>> thresholds std::vector<std::vector<int>>(), bool invert false, std::vector<int> roi std::vector<int>(), int x_stride 2, int y_stride 1, int area_threshold 10, int pixels_threshold 10, bool robust false) ``` #### save item doc **type** func **brief** Save image to file **param** **path**: file path<br>**quality**: image quality, by default(value is 95), support jpeg and png format<br> **return** error code, err::ERR_NONE is ok, other is error **static** False **C++ defination code**: ```cpp err::Err save(const char *path, int quality 95) ``` #### flood\\_fill item doc **type** func **brief** Flood fills a region of the image starting from location x, y. **param** **x**: The x coordinate of the seed point.<br>**y**: The y coordinate of the seed point.<br>**seed_threshold**: The seed_threshold value controls how different any pixel in the fill area may be from the original starting pixel. default is 0.05.<br>**floating_threshold**: The floating_threshold value controls how different any pixel in the fill area may be from any neighbor pixels. default is 0.05.<br>**color**: The color to fill the region with. default is white.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**clear_background**: If true, the background will be cleared before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None. FIXME: the mask image works abnormally<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *flood_fill(int x, int y, float seed_threshold 0.05, float floating_threshold 0.05, image::Color color image::COLOR_WHITE, bool invert false, bool clear_background false, image::Image *mask nullptr) ``` #### erode item doc **type** func **brief** Erodes the image in place. **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: The number of pixels in the kernel that are not 0. If it is less than or equal to the threshold, set the center pixel to black. default is (kernel_size 1).<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *erode(int size, int threshold 1, image::Image *mask nullptr) ``` #### dilate item doc **type** func **brief** Dilates the image in place. **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: The number of pixels in the kernel that are not 0. If it is greater than or equal to the threshold, set the center pixel to white. default is 0.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *dilate(int size, int threshold 0, image::Image *mask nullptr) ``` #### open item doc **type** func **brief** Performs erosion and dilation on an image in order. **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: As the threshold for erosion and dilation, the actual threshold for erosion is (kernel_size 1 threshold), the actual threshold for dialation is threshold. default is 0.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *open(int size, int threshold 0, image::Image *mask nullptr) ``` #### close item doc **type** func **brief** Performs dilation and erosion on an image in order. **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: As the threshold for erosion and dilation, the actual threshold for erosion is (kernel_size 1 threshold), the actual threshold for dialation is threshold. default is 0.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *close(int size, int threshold 0, image::Image *mask nullptr) ``` #### top\\_hat item doc **type** func **brief** Returns the image difference of the image and Image.open()’ed image. **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: As the threshold for open method. default is 0.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *top_hat(int size, int threshold 0, image::Image *mask nullptr) ``` #### black\\_hat item doc **type** func **brief** Returns the image difference of the image and Image.close()’ed image. **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: As the threshold for close method. default is 0.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False **C++ defination code**: ```cpp image::Image *black_hat(int size, int threshold 0, image::Image *mask nullptr) ``` #### find\\_blobs item doc **type** func **brief** Finds all blobs in the image and returns a list of image.Blob class which describe each Blob.\\nPlease see the image.Blob object more more information. **param** **thresholds**: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br>**invert**: if true, will invert thresholds before find blobs, default is false<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**x_stride**: x stride is the number of x pixels to skip when doing the hough transform. default is 2<br>**y_stride**: y_stride is the number of y pixels to skip when doing the hough transform. default is 1<br>**area_threshold**: area threshold, if the blob area is smaller than area_threshold, the blob is not returned, default is 10<br>**pixels_threshold**: pixels threshold, if the blob pixels is smaller than area_threshold, the blob is not returned,, default is 10.<br>when x_stride and y_stride is equal to 1, pixels_threshold is equivalent to area_threshold<br>**merge**: if True merges all not filtered out blobs whos bounding rectangles intersect each other. default is false<br>**margin**: margin can be used to increase or decrease the size of the bounding rectangles for blobs during the intersection test.<br>For example, with a margin of 1 blobs whos bounding rectangles are 1 pixel away from each other will be merged. default is 0<br>**x_hist_bins_max**: if set to non zero populates a histogram buffer in each blob object with an x_histogram projection of all columns in the object. This value then sets the number of bins for that projection.<br>**y_hist_bins_max**: if set to non zero populates a histogram buffer in each blob object with an y_histogram projection of all rows in the object. This value then sets the number of bins for that projection.<br> **return** Return the blob when found blobs, format is (blob1, blob2, ...), you can use blob class methods to do more operations. **static** False **C++ defination code**: ```cpp std::vector<image::Blob> find_blobs(std::vector<std::vector<int>> thresholds std::vector<std::vector<int>>(), bool invert false, std::vector<int> roi std::vector<int>(), int x_stride 2, int y_stride 1, int area_threshold 10, int pixels_threshold 10, bool merge false, int margin 0, int x_hist_bins_max 0, int y_hist_bins_max 0) ``` #### find\\_lines item doc **type** func **brief** Find lines in image **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**x_stride**: x stride is the number of x pixels to skip when doing the hough transform. default is 2<br>**y_stride**: y_stride is the number of y pixels to skip when doing the hough transform. default is 1<br>**threshold**: threshold threshold controls what lines are detected from the hough transform. Only lines with a magnitude greater than or equal to threshold are returned.<br>The right value of threshold for your application is image dependent. default is 1000.<br>**theta_margin**: theta_margin controls the merging of detected lines. default is 25.<br>**rho_margin**: rho_margin controls the merging of detected lines. default is 25.<br> **return** Return the line when found lines, format is (line1, line2, ...), you can use line class methods to do more operations **static** False **C++ defination code**: ```cpp std::vector<image::Line> find_lines(std::vector<int> roi std::vector<int>(), int x_stride 2, int y_stride 1, double threshold 1000, double theta_margin 25, double rho_margin 25) ``` #### find\\_line\\_segments item doc **type** func **brief** Finds all line segments in the image. **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**merge_distance**: The maximum distance between two lines to merge them. default is 0.<br>**max_theta_difference**: The maximum difference between two lines to merge them. default is 15.<br> **return** Return the line when found lines, format is (line1, line2, ...), you can use line class methods to do more operations **static** False **C++ defination code**: ```cpp std::vector<image::Line> find_line_segments(std::vector<int> roi std::vector<int>(), int merge_distance 0, int max_theta_difference 15) ``` #### find\\_circles item doc **type** func **brief** Find circles in image **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**x_stride**: x stride is the number of x pixels to skip when doing the hough transform. default is 2<br>**y_stride**: y_stride is the number of y pixels to skip when doing the hough transform. default is 1<br>**threshold**: threshold controls what circles are detected from the hough transform. Only circles with a magnitude greater than or equal to threshold are returned.<br>The right value of threshold for your application is image dependent.<br>**x_margin**: x_margin controls the merging of detected circles. Circles which are x_margin, y_margin, and r_margin pixels apart are merged. default is 10<br>**y_margin**: y_margin controls the merging of detected circles. Circles which are x_margin, y_margin, and r_margin pixels apart are merged. default is 10<br>**r_margin**: r_margin controls the merging of detected circles. Circles which are x_margin, y_margin, and r_margin pixels apart are merged. default is 10<br>**r_min**: r_min controls the minimum circle radius detected. Increase this to speed up the algorithm. default is 2<br>**r_max**: r_max controls the maximum circle radius detected. Decrease this to speed up the algorithm. default is min(roi.w / 2, roi.h / 2)<br>**r_step**: r_step controls how to step the radius detection by. default is 2.<br> **return** Return the circle when found circles, format is (circle1, circle2, ...), you can use circle class methods to do more operations **static** False **C++ defination code**: ```cpp std::vector<image::Circle> find_circles(std::vector<int> roi std::vector<int>(), int x_stride 2, int y_stride 1, int threshold 2000, int x_margin 10, int y_margin 10, int r_margin 10, int r_min 2, int r_max 1, int r_step 2) ``` #### find\\_rects item doc **type** func **brief** Finds all rects in the image. **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**threshold**: The threshold to use for the rects. default is 10000.<br> **return** Returns the rects of the image **static** False **C++ defination code**: ```cpp std::vector<image::Rect> find_rects(std::vector<int> roi std::vector<int>(), int threshold 10000) ``` #### find\\_qrcodes item doc **type** func **brief** Finds all qrcodes in the image. **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br> **return** Returns the qrcodes of the image **static** False **C++ defination code**: ```cpp std::vector<image::QRCode> find_qrcodes(std::vector<int> roi std::vector<int>()) ``` #### find\\_apriltags item doc **type** func **brief** Finds all apriltags in the image. **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**families**: The families to use for the apriltags. default is TAG36H11.<br>**fx**: The camera X focal length in pixels, default is 1.<br>**fy**: The camera Y focal length in pixels, default is 1.<br>**cx**: The camera X center in pixels, default is image.width / 2.<br>**cy**: The camera Y center in pixels, default is image.height / 2.<br> **return** Returns the apriltags of the image **static** False **C++ defination code**: ```cpp std::vector<image::AprilTag> find_apriltags(std::vector<int> roi std::vector<int>(), image::ApriltagFamilies families image::ApriltagFamilies::TAG36H11, float fx 1, float fy 1, int cx 1, int cy 1) ``` #### find\\_datamatrices item doc **type** func **brief** Finds all datamatrices in the image. **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**effort**: Controls how much time to spend trying to find data matrix matches. default is 200.<br> **return** Returns the datamatrices of the image **static** False **C++ defination code**: ```cpp std::vector<image::DataMatrix> find_datamatrices(std::vector<int> roi std::vector<int>(), int effort 200) ``` #### find\\_barcodes item doc **type** func **brief** Finds all barcodes in the image. **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br> **return** Returns the barcodes of the image **static** False **C++ defination code**: ```cpp std::vector<image::BarCode> find_barcodes(std::vector<int> roi std::vector<int>()) ``` #### find\\_displacement item doc **type** func **brief** Finds the displacement between the image and the template. TODO: support in the feature\\nnote: this method must be used on power of 2 image sizes **param** **template_image**: The template image.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**template_roi**: The region of interest rectangle (x, y, w, h) to work in. If not specified, it is equal to the image rectangle.<br>**logpolar**: If true, it will instead find rotation and scale changes between the two images. default is false.<br> **return** Returns the displacement of the image **static** False **C++ defination code**: ```cpp image::Displacement find_displacement(image::Image &template_image, std::vector<int> roi std::vector<int>(), std::vector<int> template_roi std::vector<int>(), bool logpolar false) ``` #### find\\_template item doc **type** func **brief** Finds the template in the image. **param** **template_image**: The template image.<br>**threshold**: Threshold is floating point number (0.0 1.0) where a higher threshold prevents false positives while lowering the detection rate while a lower threshold does the opposite.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image. Only valid in SEARCH_EX mode.<br>**step**: The step size to use for the template. default is 2. Only valid in SEARCH_EX mode<br>**search**: The search method to use for the template. default is SEARCH_EX.<br> **return** Returns a bounding box tuple (x, y, w, h) for the matching location otherwise None. **static** False **C++ defination code**: ```cpp std::vector<int> find_template(image::Image &template_image, float threshold, std::vector<int> roi std::vector<int>(), int step 2, image::TemplateMatch search image::TemplateMatch::SEARCH_EX) ``` #### find\\_features item doc **type** func **brief** Finds the features in the image. TODO: support in the feature **param** **cascade**: The cascade to use for the features. default is CASCADE_FRONTALFACE_ALT.<br>**threshold**: The threshold to use for the features. default is 0.5.<br>**scale**: The scale to use for the features. default is 1.5.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br> **return** Returns the features of the image **static** False **C++ defination code**: ```cpp std::vector<int> find_features(int cascade, float threshold 0.5, float scale 1.5, std::vector<int> roi std::vector<int>()) ``` #### find\\_lbp item doc **type** func **brief** Finds the lbp in the image. TODO: support in the feature. **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br> **return** Returns the lbp of the image **static** False **C++ defination code**: ```cpp image::LBPKeyPoint find_lbp(std::vector<int> roi std::vector<int>()) ``` #### find\\_keypoints item doc **type** func **brief** Finds the keypoints in the image. TODO: support in the feature. **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**threshold**: The threshold to use for the keypoints. default is 20.<br>**normalized**: If true, the image will be normalized before the operation. default is false.<br>**scale_factor**: The scale factor to use for the keypoints. default is 1.5.<br>**max_keypoints**: The maximum number of keypoints to use for the keypoints. default is 100.<br>**corner_detector**: The corner detector to use for the keypoints. default is CORNER_AGAST.<br> **return** Returns the keypoints of the image **static** False **C++ defination code**: ```cpp image::ORBKeyPoint find_keypoints(std::vector<int> roi std::vector<int>(), int threshold 20, bool normalized false, float scale_factor 1.5, int max_keypoints 100, image::CornerDetector corner_detector image::CornerDetector::CORNER_AGAST) ``` #### find\\_edges item doc **type** func **brief** Finds the edges in the image. **param** **edge_type**: The edge type to use for the edges. default is EDGE_CANNY.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**threshold**: The threshold to use for the edges. default is 20.<br> **return** Returns the edges of the image **static** False **C++ defination code**: ```cpp image::Image* find_edges(image::EdgeDetector edge_type, std::vector<int> roi std::vector<int>(), std::vector<int> threshold std::vector<int>({100, 200})) ``` #### find\\_hog item doc **type** func **brief** Finds the hog in the image. TODO: support in the feature **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**size**: The size to use for the hog. default is 8.<br> **return** Returns the hog of the image **static** False **C++ defination code**: ```cpp image::Image* find_hog(std::vector<int> roi std::vector<int>(), int size 8) ``` #### match\\_lbp\\_descriptor item doc **type** func **brief** Matches the lbp descriptor of the image. TODO: support in the feature **param** **desc1**: The descriptor to use for the match.<br>**desc2**: The descriptor to use for the match.<br> **return** Returns the match of the image **static** False **C++ defination code**: ```cpp int match_lbp_descriptor(image::LBPKeyPoint &desc1, image::LBPKeyPoint &desc2) ``` #### match\\_orb\\_descriptor item doc **type** func **brief** Matches the orb descriptor of the image. TODO: support in the feature **param** **desc1**: The descriptor to use for the match.<br>**desc2**: The descriptor to use for the match.<br>**threshold**: The threshold to use for the match. default is 95.<br>**filter_outliers**: If true, the image will be filter_outliers before the operation. default is false.<br> **return** Returns the match of the image **static** False **C++ defination code**: ```cpp image::KPTMatch match_orb_descriptor(image::ORBKeyPoint &desc1, image::ORBKeyPoint &desc2, int threshold 95, bool filter_outliers false) ```"}}